text
"You can show a view over the lock screen while the device is locked using foreground notification services, you would customize the default notification view with the custom XML notification layout and the foreground service has the capability to change the content of the view in real-time."
Add the below lines in your onCreate method of the activity
"When your device is locked while the activity is open, it will remain in the lock screen with the back button so you can again navigate to the lock screen if needed."
You overrode the wrong onCreate - you do not want to use the PersistableBundle version.
Each keyboard app has its own layout and you can't change it.
You must override onCreate method in your custom dialog implementation and call setContentView there.
Both setContentView and findViewById methods are available and you can use them to manage your dialog UI.
"Remove extra "";"" after protected void onCreate; and (Bundle)savedInstanceState) ; and end it with ""}"""
You see in the Log that the code inside the onCreate() is executed.
"To get the data from the intent you used to start an Activity, you should ask for the intent instead of creating a new one."
"viewLifecycleOwner is tied to when the fragment has (and loses) its UI (onCreateView(), onDestroyView())"
You need to use findViewById() and use setOnClickListener() inside onCreate() method
In App Info screen from the system Settings app > Other permissions > Display pop-up windows while running in the background.
"UPDATE: To check if this permission is granted you could use an already running service and launch a dummy transparent activity, and in the onCreate call back on a LocalBroadcastManager or similar and you'll know it's granted."
"It's an ugly solution, but it may be useful for some."
My workaround is simple: call it from a fragment's onCreateView.
"Fragment implements LifecycleOwner which maps its create and destroy events to the fragment's onCreate and onDestroy, respectively."
"Fragment.getViewLifecycleOwner() maps its create and destroy events to the fragment's onViewCreated and onDestroyView, respectively."
"Fact of the matter is, onCreate() is called first then onStart() follows."
"Remember when onCreate is called, whatever code is executed there, it does not pause onStart from being called."
"Likewise, onStart is not waiting for all the code inside onCreate to finish before exeuting it's own code."
Seems you want to do something inside onStart after you get your dataset from firebase eventlisteners inside onCreate.
"First of all, delete the setOnTouchListener method that you provide in the onCreate entirely."
"Next, define a selector color in the res/color directory like the following."
"EDIT: According to Ian Lake on Twitter (see https://twitter.com/ianhlake/status/1193964829519667202), the fact that FragmentActivity attempts to dispatch onActivityCreated in onStart is irrelevant, because no matter what happens, the FragmentManager dispatches it anyway when going from onCreate to onStart."
"ORIGINAL: Yes, in a FragmentPagerAdapter they use FragmentTransaction.detach / FragmentTransaction.attach, which causes the View to be destroyed, but the Fragment stays alive (stopped, but not destroyed)."
"ORIGINAL: It's actually a bad practice, and should be done in onViewCreated, providing getViewLifecycleOwner() as the lifecycle owner."
"UPDATE: Despite that the FragmentActivity only tries to dispatch it once, all Fragments always go through onActivityCreated, because that's just how the FragmentManager works."
"ORIGINAL: It is not always called after onCreateView, in fact, it's more-so called ""before onStart, but only once""."
"UPDATE: but apparently this doesn't really matter to the FragmentManager, because it goes CREATED -&gt; ACTIVITY_CREATED -&gt; STARTED either way."
There are two different lifecycles because the Fragment itself lives longer than the Fragment's view.
"However, the lifecycle of Fragment itself is not destroyed - it generally stays as CREATED."
Where this becomes a problem is when it comes to how LiveData works.
"When you observe a LiveData, LiveData automatically unregisters the observer when the lifecycle reaches DESTROYED."
"By using the view LifecycleOwner in onCreateView()/onViewCreated(), you ensure that you'll only have one active Observer running at a time and that Observers tied to previous view instances are correctly destroyed along with the view."
"Therefore, yes, you should always use getViewLifecycleOwner() as the LifecycleOwner when in onCreateView() or onViewCreated(), including when using Data Binding."
"Of course, if you're registering an Observer in onCreate(), then the view LifecycleOwner does not exist yet (it is created right before onCreateView()) and you don't have the multiple registration problem, which is why the Lint check specifically does not apply to any registrations done at onCreate() time."
"In those cases, using the Fragment's lifecycle itself is absolutely correct."
"onCreate() will only be called when your fragment is being, well, created."
"Detaching and reattaching don't create new fragments, but onCreate() will also be called if your activity is destroyed and recreated (e.g., on a configuration change like rotation or if your app's process is killed)."
"The results would get piped through some LiveData held by the ViewModel, one that you observe in onCreate()."
"You could still have a searchQuery() method that you call, but it would return void."
"That way, after a configuration change, you once again observe that LiveData, and you get the data as it was prior to that configuration change."
"Like post() on a View, launch() (usually) schedules work to be performed asynchronously with respect to the current bit of execution."
"However, your onCreate() function will continue past the point of launch() to do whatever else it is supposed to."
"However, just like a Runnable passed to post() could still tie up the main application thread due to what work it does in run(), your coroutine could still tie up the main application thread."
It's just that this work would happen later than it would if you did the work directly in onCreate().
"Inflate your binding binding = YourClassBinding.inflate(layoutInflater) inside Activity's onCreate and call setContentView(binding.root), or inflate it in Fragment's onCreateView then return it: return binding.root"
"Reference views in code via binding using their ids binding.textView.text = ""Hello, world!"""
You need to put the setOnClickListener in one of the activity callbacks.
"In your onCreate() method, move the button there and then setOnClickListener()."
For more information please refer to Understand the Activity Lifecycle.
The solution for my issue was to create 3 runnables and start them in onCreate() Method.
These strings are initialized at the beginning in the onCreate() method.
When you click the button the buttonLogIn.setOnClickListener is executed with the same values initialized (empty values).
Looks like your activity set the content view to the activity_display_message.xml layout in your setContentView in your onCreate function.
Hence the findViewById will only find the references from that layout only.
Just add 1 more parameter in your adapter and pass the title
You need to put values in your gameresult inside onCreate() method
"You can put this, at the first line in the onCreate method of your launcher activity."
Therefore any setup you do in onCreate() should be guarded with a if (savedInstanceState == null) check to ensure that you don't add additional Fragments on top of the ones already restored.
"On your main activity's XML, remove the following fields inside the &lt;fragment&gt; tag:  app:defaultNavHost=""true"" and app:navGraph"
"After that in your activity, after you have performed build, in the onCreate"
You got the first step right: You need to set up GoogleSignInOptions but you miss to pass them to a GoogleSignInClient.
Call this method when the sign in button is clicked or you want to start sign in.
"Yes, it's possible to scope a viewmodel to a navgraph now starting with androidx.navigation:*:2.1.0-alpha02."
All you need to give is the R.id for your navgraph.
'onCreateView() method is only for fragment it cannot be override in activity.'
put you all the code in onCreate() method of your activity.
"There's no need to block, either with Thread#sleep or with while loops, as the permission request is asynchronous."
"Put that code in your Application class' onCreate() method, for example, and then you'll be able to use hidden APIs like normal."
"Simply passing ""L"" to this method will exempt all hidden APIs, and we can do that with double-reflection."
"For a full Java example of this, check out the FreeReflection library linked in the JNI section, or follow through the source below."
That's because your activity calls super.onCreate() early in its onCreate().
"Just to make it clear: This is how it should be called, you made no mistake."
Cocos2dxActivity authors chose to load the native library during onCreate().
"They had a good reason to make this decision: it allowed them to extract android.app.lib_name from your package, and this way to choose the correct library."
"The bottom line, you can move initialization of the ami field into AppActivity.onCreate(), if you like this way, or you can use the static block in your AppActivity, if you prefer."
"it resolves your problem with field initialization), but it has its own drawbacks, too."
I'm creating a notification channel in the top of onCreate().
The easiest way to figure out exactly when injection happens is to inspect the code that AndroidAnnotations generates.
"In onCreate, the MainActivity_ instance is registered as an OnViewChangedNotifier."
"setContentView calls notifyViewChanged, which triggers a (synchronous) call to onViewChanged."
"Therefore, @ViewById-annotated views are bound and available for use after onCreate has been called, and @AfterViews-annotated methods will be executed at the end of onCreate and before any other Activity lifecycle method."
"onViewChanged binds all fields annotated with @ViewById, then calls all methods annotated with @AfterViews."
"In onCreate, the MainFragment_ instance is registered as an OnViewChangedNotifier."
"onViewCreated calls notifyViewChanged, which triggers a (synchronous) call to onViewChanged."
The only guarantee is that activity's onCreate will always be called first.
You should be performing that task once - probably in onCreate - and then saving it off to a class-level property.
You don't want to use findViewById inside a click listener.
You don't really need to be using a launch inside that click listener.
You haven't performed the dependency injection in that view .
"(in case you are not using Dagger for Android ) , in your onCreate method."
"In that case , Dagger will know that it has some dependencies to be injected in that fragment , in your case the HomeViewModel ."
"Look at the manual at page 52-61 everything is explained, i had to implement it with a ET55, but it seems to be the same process."
You can create a progress dialog to show to user that you are fetching data
"In onCreate, you need to call setContentView before using any findViewById calls."
startForegroundService() will trigger a call to onCreate() if that service is not already running.
The issue is that your context (the this parameter) is null before your onCreate() method is called.
What you can do is initialise this field with a lazy call.
"Because you override wrong method in BaseActivity, that why your app crash."
"When LoginScreen activity is created, Android will call its onCreate method."
"The first line super.onCreate(savedInstanceState) will call onCreate method of its parent, in this case onCreate (bundle) in BaseActivity activity will be called."
"Unfortunately, in BaseActivity activity, you override and put the initial code for applicationController in another method onCreate(bundle, persistentState) which quite similar to onCreate (bundle)."
The performance of a lambda will be at least as good as creating an anonymous inner class.
"Note that if this is only done during setup, like in onCreate, this will mean just 1 object allocation as well."
"In this case, you get as many object allocations as many times you run the method the lambda's in."
"In that case you should use onNewIntent to 'update' intent, because onCreate and onResume will not handle it."
"In the onCreate() of your application, first invoke pruneWork() on WorkManager to remove all piled up cancelled worker schedules."
Remember the method returns Operation which will help you check the completion of removal.
"You have the onCreate method twice, delete the second one."
You should just never specify a constructor manually (except in very narrow cases that are outside the scope of this question).
"I've removed the if check from onCreate() because we know that the arguments bundle will always be non-null, so the check is useless."
"The Bundle class can handle many different types of data; this example is using Strings but you can use ints or Lists, etc."
"The only way for it to not be non-null is if someone doesn't call newInstance(), and we're much better off crashing and fixing that problem than trying to soldier on without the data we need."
"You can call getArguments() from any method, not just onCreate()."
Answering my own question as I found the correct approach in the updated Navigation documentation.
"At the time of writing this answer, I am using Navigation 2.2.0-alpha01"
Try setting up onClickListener of Fab button in onStart of the Activity as in onCreate Activity is just inflating the View and haven't set the NavHostController.
"As you can see from the stacktrace, the crash happens from the second intent you launch yourself within onCreate."
The problem is that you're specifying package on the intent
"Based on what I can see you are missing a fragment transaction, so I am guessing you are displaying the fragment statically, defining it in the xml file (you need to post the activity_layout.xml file to be sure)"
"Basically, In my understanding just bt providing id of the correct fragment for the menu item and calling setupWithNavController should work, but that assumption was not correct, or maybe in the current version (1.0.0-alpha07) Google guys changed something."
"Looking at the cylinder model, it has a UV map of 0 to 1."
"Okay, I realised where the ""class Models does not exist"" thing comes from."
"To fix the layout, the onCreate method had to be changed to"
"The binding auto-name-conversion thing must have thought Models was a class, not a package."
THIS IS IMPORTANT CODE FOR GETTING TEXT AND DRAWING RECTANGLE ON IT
"Even if your table was created, you could not add data in it with the addData() method because you don't supply a value for the id column."
then uninstall the app from the emulator/device so the db is deleted and run again.
"  Activity B's onCreate(), onStart(), and onResume() methods execute in sequence."
As you can guess the idea is save data in onSaveInstanceState and retrieve in onRestoreInstanceState or onCreate.
Because the activity will be recreated so onSaveInstanceState and onRestoreInstanceState will be called as well.
"In this case, middle activities doesn't start at all (onCreate method isn't called) and after pressing back button, they'll be started."
There is some weird scenarios such as starting multiple singleInstance activities sequentially.
"As mentioned here Background Service Limitations, the app/service has five seconds to call startForeground(), If the app does not call startForeground() within the time limit, the system stops the service and declares the app to be ANR."
"Or if  the foreground service is already instantiated and its getting called again, then the onCreate method will not be called, instead onStartCommand will be called."
Either your foreground service gets destroyed/finished before calling the  startForeground() method.
"Put your logic in its own function(s), outside of onCreate()."
Create a local variable job and initialize it in onCreate().
"(I tried to write private val job: Job = Job(), but bumped into problem that in ViewPager you will create Fragments and their jobs."
There is no way to do exactly what you want with periodic work in a clean way.
"With this setup, your onCreate() of Application can safely use ExistingWorkPolicy.KEEP to avoid rescheduling work if you already have a WorkRequest queued up and when that queued up work fires, the next WorkRequest will be queued up with the appropriate new period."
"Your method hasn't finished executing, so the Handler needs to wait until it has before it can post your Runnable."
"Once Toast 1 runs, onCreate() has finished executing, and the Handler has availability to execute that Runnable."
"The Looper executes it as soon as it can, but that can't be while your method is still executing."
"You solved your immediate problem by adding the dependency, but let me add a note on your usage of GlobalScope."
Try to use onNewIntent to know Activity A is relaunched.
"Nothing is happening on click, because you have not set the onClickListener on the button yet, you've only defined the functionality for onClick."
A few lines down you'll see a call to ActivityThread#handleStartActivity() which is what calls onStart().
Check the source comments in Activity.java for more details on how Activity lifecycles work.
"Note that if you wanted to use BottomSheetFragment for the NavigationView opening, you'll need setSupportActionBar in order to set menus for the BottomAppBar and I couldn't still find a way to fix this."
In your Service's onCreate() context = this cannot be null by a fundamental programming paradigm.
You are just Declaring the EditText inside the Scope of onCreate() method.
"Whenever you call startService() or startForegroundService() in Android, the framework checks if that Service is already running."
"That means, if you have any one-time initialization in your Service that you don't want to be reinitalized, put it in onCreate()."
"However, every time you call startService() or startForegroundService(), the Service's onStartCommand() method will be called."
Can someone please explain a scenario where we can skip a method and rest lifecycle works perfectly fine.
"It never can happen unless you manually call finish(), say, in onCreate() which is quite pointless."
"If a lifecycle method is ""skipped"" by the system (and the only scenario when it happens is an app process being killed) the rest of the methods are also ""skipped""."
To understand what is happening you need to know the Activity lifecycle
"As you can see, when the app is launched, the first thing that's going to run is your onCreate() in this case, onCreate() has a method that inflates the view of your Activity, that method is called setContentView()."
"so, if you execute your code below setContentView, it will first inflate the view of MainActivity or the class you are in, and then just go to your other Activity."
To launch your WelcomeActivity just do this in your Manifest
where getSavedLocale() is the Locale corresponding to the current region (this will be specific for your project ... ).
"Yes, you can and should move it to the Application's sub-classed onCreate() if you have it."
"""If you have an Application subclass, then you can place Fabric.with() in the onCreate() method."
"Otherwise, if you have multiple launch activities in your app, then add Fabric.with() to each launch activity."
"You are implementing the wrong concepts.., which creates problem.., To tackle it .. you are again implementing wrong things.."
CONNECTIVITY_CHANGE is an example and it would be your intent action / broadcast you want to listen for...!
Our service is START_STICKY Even if it is destroyed; gets started automatically and registers mCallBroadcastReceiver in onCreate again..
It will go in your onCreate which will call Startforeground with the notification to start this service as a foreground service
In and above O you can not run foreground service without proper Ongoing task notification...
I've been working on this question and this is my solution.
"UPDATE: This is working for us in Prod, but it's not 100%."
"In onCreate() initialize it and then anytime you want to start a service in onResume just call resumingServiceManager.startService(this, intent)"
It's lifecycle aware so it will clear the disposable if it pauses cancelling the onSuccess from triggering when it might be on the way to the background with an immediate open/close.
The parameter v in onDelete(View v) is not the CardView that you want to be removed.
"You could combine left/right padding each equal to half the screen width with the android:clipToPadding=""false"" attribute on your scrollview."
Creating ViewModels in onCreate() as opposed to onCreateView() for both the parent and child Fragments.
Initializing request for data (Firebase Firestore query) data of child Fragment (PriceFragment) in onCreate() rather than onViewCreated() but still doing so only when saveInstanceState is  null.
Your Activity is only considered to be in the foreground once onResume() has been called.
That's why starting the IntentService from onCreate() is not allowed
My project hosts AdMob ads and I call the MobileAds.initialize() method inside my Application class onCreate().
"The ads initializer loads a WebView which is now forbidden to do in a new process before you call the WebView.setDataDirectorySuffix(""dir_name_no_separator"") method."
"When the second process is created, it also goes through the same application create flow, meaning it calls the same onCreate() inside the Application class, which calls the  MobileAds.initialize() that tries to create a new WebView instance and by that causes the crash."
There are two ways you could go about sharing information between activities and fragments.
"Let me start by saying that @madlymad has the right idea, and you should create a BaseFragment class if you haven't already."
"However if for some reason you can't or don't want to, you can instead set the orientation in the Fragment's onAttached(), onCreate() or onCreateView()"
According to official document of Android 8.0 Background Execution Limits
Note: Apps targeting API Build.VERSION_CODES.P or later must request the permission Manifest.permission.FOREGROUND_SERVICE in order to use this API.
  It is crucial to call AndroidInjection.inject() before super.onCreate() in an Activity
Let's see what is going wrong here at very high level..
Activity will retain it's ViewModel on rotation using onRetainNonConfigurationInstance and will restore it in onCreate()
"As we are injecting before the call to super.onCreate(), we will not get the retained MainViewModel object but the new one."
"When dagger tries to inject MainViewModel it calls provideMainViewModel() method of MainModule, which invokes following expression (keep in mind super.onCreate() is not yet called)"
The ViewModelProviders.of will return a ViewModelProvider which holds the references for ViewModelStore of respective activity and ViewModelProviderFactory
Whenever the device gets rotated activity retains it's non configuration instance state using onRetainNonConfigurationInstance and restores it in onCreate.
"ViewModelStore is a wrapper over Map&lt;String, ViewModel&gt; with additional method clear()"
ViewModelProvider.get will try to fetch the ViewModel from activity's ViewModelStore
In this particular example; as we haven't called super.onCreate() method yet the implementation will ask factory to create it and will update the corresponding ViewModelStore.
You are trying to access **xml** instances before it get's created that's makes app causing to crashed.
To check the caused due to your app crashed you may refer to check Logcat into your IDE.
Because you are doing findViewById outside onCreate() without doing setContentView()
"There is a common misuse of the splash screen when it is shown to the user for some amount of seconds, and users are wasting their time looking at the Splash screen while they could already interact with the App."
In the onCreate of the ChatFragment you should check if the user already has a profile and redirect them to the ProfileFragment using conditional navigation if they don't.
In your case it would make sense to make the ChatFragment the fixed destination.
"Check this value in onResume(), if it differs, you can conclude the locale was change and recreate()"
The first authorListImageView.setOnClickListener code you listed would go in onCreate
"The one of the main goals of the presenter layer is to be Android Framework independent, that means that you don't have in imports any of the packages from Android Framework, making it pure Java class."
"You should make your Activity or Fragment implements the ActivityView interface or FragmentView interface, ant let concrete Activity or Fragment implement that interface."
"The Activity shouldn't have any MutablieLiveData member variables, that should be inside the ViewModel."
"That is, because ArticleRepository is recreated again inside your ViewModel with a new set of MutableLiveData, the previous one you subscribed to is no longer relevant - and you only subscribe once onCreate()."
"The reason for why it only works the first time, is because the first time you observe something it notifes as changed, however because your arrangement is incorrect it never updates again."
You should separate bind from async-tasks such as loadData() they are not the same thing.
"All this said, a presenter that is scoped @PerActivity will always be a new object when you create a new ActivityComponent (DaggerActivityComponent.build()) in your onCreate method."
"You recreate the component, and that new component will create new objects."
"make sure you define sharedPreferences and also SELECTED_LANGUAGE , ENGLISH etc, consts"
also Override the base context by adding the following code
"onResume is executed right after onCreate and your async task was executing twice, that's why it was duplicated in the first place."
"When you hit the back only the onResume was executed, so the problem would happen then."
Kotlin treats null as a first class citizen by distinguishing nullable types (e.g.
"for example, the first time an Activity instance is created, onCreate() is called with a null Bundle because there is no state to be restored."
"as you know, a Bundle instance can be null depending on what phase of the component's lifecycle you're currently in."
"if that same Activity is re-created due to a configuration change, however, onCreate() can be called with a non-null Bundle instance (in which you may have stored some data to help recreate the associated screen)."
"It seems like you're setting the support action bar, so you'd have to use the support action bar in the onCreateView method too."
"The actionBar is null, that's why the code to set the title won't run."
"The other problem I think you might run into is that you're adding the support action bar in the activity's onCreate method, but you're trying to access it in the fragment's onViewCreated which comes before according to this (I haven't really tried this out, it's just from looking at the diagram)."
"If this is the case, then you'd have to change it."
"Taking consideration that your host activity is MainActivity, just add the following code to your MainActivity's onCreate fun"
It's subsuquent use in onCreate() will not compile as that variable has not been declared in scope to that method.
int randomNumber; declares a local variable that goes out of scope immediately after the guessclick() method returns.
"I'm guessing they meant to declare randomNumber as an instance field of MainActivity,"
Here is my helper class for the Google Consent SDK that I use in my app.
To do this register a plane tapped listener in onCreate()
It will not be called if the Service is already running.
"In your case, create the fragment instance and attach it in activity onCreate, then call sortByPopularity later in a click event."
"After a successful commit, onAttach method in the fragment is called, the view is created and then you can interact with its views."
"To independently control the transluscency of the status and navigation bars on KitKat, you can simply use the window manager flags FLAG_TRANSLUSCENT_STATUS and FLAG_TRANSLUSCENT_NAVIGATION in the onCreate() method of your activity."
"However, on KitKat the system may draw a semi-opaque gradient scrim drawable over the status bar."
You're writing your code outside of MainActivity's onCreate (or any other) method scope.
In your onCreate method you are calling addPreferencesFromResource  method twice in the following code's first and last line.
Just add code this in the onCreate method of your [CurrentActivity].java file.
Add the following lines of code in the onStart() and onStop() methods.
"In particular, activities should do as little as possible to set up"
  onCreate()  Called when the activity is starting.
Now pass this callback in your BottomSheetDialogFragment constructor when you call it.
"You have defined android:onClick=""nearhs"", but there is no method available with such name in your Activity."
"Crashlytics is initialized from a content provider, so by the time you try to disable from Application's onCreate() it's too late."
Going through the decompiled code I've seen that you can disable that initialization by adding metadata to the &lt;application> element in the manifest.
"The question is not subjected to an specific programming issue, rather it points to an application architecture."
You are calling the loadProducts(); function in the onCreate function of your MainActivity which is correct.
"If I have understood correctly, then you need to keep following things in mind."
The application should load all the items that needs to be shown in the RecyclerView when it launches.
"You must do it when Context is created, for example in onCreate()."
"if you call a function like getSystemService which needs Context, you cannot new them as class member like this."
The proper way to do this would be to call it in the onCreate() method of the Application class.
"Based on JavaFXPorts and the Kokos sample, you can add JavaFX to an Android project created with Android Studio, and you will be able to run a JavaFX scene inside an Android fragment."
a new ArrayList instance will be created each time the event is triggered.
  Called to have the fragment instantiate its user interface view
It's better to move the code that connects to the database here - code that doesn't depend on UI elements.
why this anonymous inner class instance for callback can't cause activity leak
What I had to do was to Override the onCreate() function inside MainActivity.java.
You shouldn't create your viewmModel in onCreateView but rather in onCreate so you don't add a listener to your data each time view is created.
"However if I can do nothing when app is background, I can't create my custom notification."
All of above is valid if app is not running or it's in background.
Now I press device home button and keeps the app in backgroung for long time and when I am bringing the app to the foreground by clicking on Launcher icon it is taking me to the onCreate of MainActivity.
"If the app has been in the background long enough that the OS has killed your app's process, your MainActivity will need to go through its full creation procedure, including onCreate() (though you should see that the savedInstanceState Bundle is non-null during this re-creation)."
  Here I am doubting if device is killing my app from Application backstack then it should start from SplashScreen Activity instead of MainActivity.
"Yes,I mean because of fragment .You already have one fragment onFirst load, When you rotate onCreate() will be called once again, so now fragment manager has old fragment ,so it methods will execute(once),and next you are doing transaction replace() which will remove old fragment and replace it with new once and again(onCreateView() will be called for second time)."
"for every rotatation, no.of onCreateView() calls will increase by 1. that means you are adding fragments while not removing old ones."
You can't findViewById in an activity before its content view is set.
"Try moving your array initialization into onCreate, after setting the content view."
For the menu in your BottomNavigationView you need to use bottomNavigationView.getMenu().removeItem(R.id.district_tab); in onCreate method.
"Or you can replace white screen with your AppTheme primaryColor by placing it in onCreate() method of your activity as,"
"in your LauncherActivities style.So, if you don't want to AppTheme color then you can set custom color with above method."
What you can do here is have all the subscriptions references used in your Activity in a CompositeDisposable (RxJava 2) or CompositeSubsciption (RxJava) object.
"Simply open the app, (wait for the broadcast receiver to register), minimise it, type in your code, and voila."
Note: this solution doesn't work for android:drawableLetf or android:drawableRight but allow to use app:srcCompat
"You can try one of below two options or a combination of both, which have solved my problems when I have faced them."
Add below line of code in onCreate method of service.
  Step 2: Use notification to show that your service is running.
  Step 3: Remove the notification when the service is stopped or destroyed.
You need to call FirebaseRecyclerAdapter#startListening() method to start the data listener.
"By the way, you can move the adapter declaration in the onCreate() method for better app performance."
It's best to start the listener in the activity's onStart() method and then remove the listener in the onStop() method.
Below is the code to start and stop the data listener
"On first load, this will prompt the user to accept permissions."
setContentView will override the layout and replace it with the new one.
That's why you should remove this line in showAlert() method.
The local variable in onCreate() does not exist when this code is executed.
"In the first snippet the code is executed as part of the onCreate execution so it is guaranteed to finish before onCreate returns, in the second snippet, it is executed some time later (maybe after several other callbacks)."
"You can also use in Activity, In onCreate method call before super.onCreate(...) e.g."
"Google throws this exception on Activity's onCreate method after v27, their meaning is : if an Activity is translucent or floating, its orientation should be relied on parent(background) Activity, can't make decision on itself."
"Even if you remove android:screenOrientation=""portrait"" from the floating or translucent Activity but fix orientation on its parent(background) Activity, it is still fixed by the parent, I have tested already."
"Actually, if you use match_parent as the size of ScrollView child, it will also resize when keyboard will appear and fit the ScrollView size."
You need to fix childView size at loading of the screen.
"On Android 4.3 to 5, your activity is being destroyed, and then recreated."
"On Android 7, the changes don't show up because you are probably testing on a phone with sufficient ram to keep the system from destroying  the activity."
you are inflating same thing in fragment onCreate and adapter getView
here you are replacing listview.it must be a listview item
to be able to fetch that context at any time or subclass the Application class and from its onCreate call some initialization method in your Manager and pass the context.
Now you can keep all BLE functionality completely separated from Android Service/Activity/Application stuff.
One possible fix is passing null to the onCreate() of the activity.
"In your case, what's happening is that the savedInstanceState value becomes invalid because your app process got killed and restarted after you revoke the permission."
The purpose of LifecycleObserver is to eliminate writing the boilerplate code to load and cleanup resources in onCreate() and onDestory() respectively and if we need to do the same like unregistering it in onDestory() destroys the purpose of LifecycleObserver.
You'll need to unregister manually in case you use observeForever kind of thing.
"Seems like your activity is in background and then user will be able to see the ads because once your activity is destroyed then your ads won't be able to display , no this context no activity."
"A Foreground Service is a Service that you put in the foreground state, that means, the system will not kill the process if it needs CPU or if your app is closed."
Note that onStartCommand() will be triggered each time you call startService() but onCreate() is triggered only once.
"It will still run until you stop your Service, e.g with stopSelf() or stopService();"
You need to add runtime permission for OS Marshmallow or above.
Add this code for permission to allow run time operation in splash activity in onCreate or before download process of image.
Call this method where you want location and marker and in on mapasync callback method.
  Call initializeMapView method in onCreate() or In adapter onBindViewHolder
To store multiple connection object of BluetoothGatt you can use Map&lt;&gt;
There is a case when the app go from onPause() to onCreate() without onStop() and onDestroy()  is when another app with higher priority needs memory as you see the illustration.
"  suitable operations to perform during onStop(), see onStop()."
   onStop() when you call finish() method on onCreate() see reference
What you observed is a known limitation of Gson: it won't serialize anonymous or local classes.
"As you can see in https://github.com/google/gson/issues/298, an issue was raised to change that and allow serialization of anonymous and local classes, but the issue was closed more than a year ago without a clear reason."
"As you can see, there are no constraints, this is for simplicity since you are creating the Buttons programmatically."
"Firebase Authentication does automatically remember authentication state, so the user will still be authenticated when the app is restarted."
You can use lateinit modifier which allows you to declare a non-nullable variable but assign it later in onCreate.
You can use location state changed receiver to know when user manually turns of location
Register receiver in onCreate() of Activity to start listening to GPS state changes
"IMPORTANT After the service starts, Service.startForeground() must be called within 5 seconds."
Add below line of code in onCreate method of Service.
Edit: You can check my example repo for more information.
"Make sure you are calling addDrawerListener() exactly once, because it ""add""s a listener, not ""set""s."
"That being said, make sure you are calling that code from onCreate() of activity (or similar callback of Fragment)."
"Otherwise, if you perform it, say, from onStart() or onResume(), then you are going to add a new listener each time those callbacks are being invoked."
"The FirebaseAuth.getInstance() method will never return null, so your code will work."
"  In the onCreate() method, initialize the FirebaseAuth instance."
"  When initializing your Activity, check to see if the user is currently"
"In the Kotlin code, you're calling the constructor of the Application subclass directly instead of letting the framework create it for you."
"As for UI thread, you'd use the retained fragment (or Activity/Fragment onCreate()/onDestroy()) as you normally would, but using open/close as well."
I'm not sure what your onPause() and onStop() are meant to do.
However when you start a service for the first time using Context.startService() the onCreate() method of the service is called and then onStartCommand() is called and later when you call startService() again only the onStartCommand() is called.
You have to pass Intent after getting values not to onCreate() of your Activity
"If annotations don't help, I don't think there's a way to know if an argument is nullable or not."
"By the way, mind that there are several @NonNull and @Nullable annotations (javax, android, jetbrains ...) I wouldn't be surprised if Kotlin translator only recognises some of them (but it's just a guess)"
You are not overriding the same onCreate method in those two classes.
Looking at the documentation it seems one or the other will be called depending on if persistableMode is set to persistAcrossReboots.
Take a look at where you are adding the linear layout to the grid view in onCreate().
Just for reference for others who may come up with the same question I am adding my final code below.
You just need to call mFusedLocationClient.removeLocationUpdates(mLocationCallback) in onPause() of your Activity.
for e.g inside onCreate() or onViewCreated() create a FusedLocationProviderClient instance
animHandler is going to be responsible to keep the animation running.
"In your CREATE TABLE SQL, add spaces between column names such as addhar_number and types such as TEXT."
"As already pointed out, if you want to make an Activity you need to extend Activity."
"You use @OnLifecycleEvent(Lifecycle.Event.ON_CREATE) annotation on methods, that you want to trigger automatically after onCreate is called, not on onCreate method itself."
The issue is that the username and password variables you're using in onCreate() are different from the ones you've declared at the class level.
"To workaround it, use a small time delay before showing the Snackbar."
"Because you have a time delay, remember to protect against null Activity by checking for isAdded() or check getActivity() != null."
In my case I was targeting API level &lt; Oreo and the invisible overlay method in Ch4t4's answer does not work as it does not throw an exception.
"Both things happen in onCreate(), so now every time you tap the surface view (the ""main"" view in the activity),"
"OR, don't use Application, and use a Volley-scoped singleton -- see example from documentation"
"You can force a square view by checking for ""squareness"" after layout."
Looking at your callstack it should really help you narrow down your problem.
"Now, a bit lower, it shows the line number of where this issue is happening."
"However, perhaps your code has changed since you posted your error, there isn't a .equals around that line, but I'm thinking it may be your getExternalStroage()."
"Now simply go to your activity &amp; add following line of code in onCreate method,"
"According to FirebaseApp documentation, you do not need to invoke this initialization, except that your app requires access to another Firebase project."
"In your SimpleBlog application class, initialize FirebaseApp in onCreate() method and remove it from RegisterActivity in order to have Firebase initialize into entire application, not just one Activity."
"if you (for some reason or a way of using app) start getting duplicates in your ListView, then add wordsLists.clear(); as first line inside the do{} in loadingWords() method"
"There is the need to remove listeners because the mAuth will keep of keeping track of all the listeners you added, in order to notify you when something happens."
"onStart and onStop correspond to each other, while onCreate and onDestroy correspond to each other."
You have to make the activity available to the component responsible for constructing myObject.
"In your activity's onCreate(), you can now give this to the module, which makes it available within the ActivityScope."
The component has a module that provides the MyActivity instance.
Well I digged a lot but wasn't able to find any broadcast that is sticky so that on the start of app I would get to know if the phone is connected to bluetooth headset as mentioned in the question.
The work arround that I implemented is to get the bluetooth adapter and check the connection status of the bluetooth profile as in the below code
The changes in the bluetooth state after app start are then taken care by the Broadcast listeners that i have implemented as in the question.
The FragmentManager restores the last displayed fragment after orientation change.
You should add your fragment in onCreate only if the  savedInstanceState is null.
"savedInstanceState will be null only the first time, it won't be null after orientation change."
what you can do is declare your variable in your class instead of onCreate()
Use Shared Preferences to save the current state when a user toggles a checkbox.
You can reload the data from it once you get to onCreate again.
The problem is that you are 'planting' trees in the Activities onCreate method.
"For multiple onClickListeners in kotlin (version:1.1.60), the following helped me."
Based on your description I would hazard a guess that you are checking the state in onCreate.
Init your DaggerRegisterAccountComponent in onCreate() instead of onCreateView() to make sure it will be built before using any dependency.
Consider using final for all field in RegisterAccountPresenterImpl which is set inside constructor.
"onCreate in your Activity is called again when you rotate, which means another Fragment will be created and added to your frameLayout."
"The old one will be recreated, so you have two."
If it is not null then your Activity was recreated and it is likely that the Fragment is already there.
"Having in mind that you have root dagger component, for example ApplicationComponent which you instantiate in application onCreate() method, you'll need an additional public method in your application class."
"System was on shortage of memory, so it killed the process of your app."
"User navigates to your app, now onCreate() will be called with non-null Bundle."
orientation change) - onCreate() will be called with non-null Bundle.
1) Move the DBHelper class to be a class in it's own right i.e CurrencyDBHelper.java should be :-
will result in the database being created (i.e the DBHelper's onCreate method will be called).
onCreate will only be called once for the lifetime of the
One thing you'll notice is that onCreate() is called before onStart().
"The way I would work around this is to start your service in onCreate() (so it will start as soon as your activity is first created) and then read the value inside onResume(), so that every time your activity comes back into the foreground it will update according to the service."
"You may also notice that if resources are required, your app could be killed as early as onPause()."
"The exception was thrown because you attempted to commit a FragmentTransaction after the activity’s state had been saved, resulting in a phenomenon known as Activity state loss."
"A large majority of applications will only ever commit transactions the very first time onCreate() is called and/or in response to user input, and will never face any problems as a result."
"However, as your transactions begin to venture out into the other Activity lifecycle methods, such as onActivityResult(), onStart(), and onResume(), things can get a little tricky."
"For example, you should not commit transactions inside the FragmentActivity#onResume() method, as there are some cases in which the method can be called before the activity’s state has been restored (see the documentation for more information)."
"These two methods are guaranteed to be called after the Activity has been restored to its original state, and therefore avoid the possibility of state loss all together."
The update is only triggered if the db is accessed for writing or reading.
"Usually, you would just call a method of your Database class somewhere (for example for querying entities) and that is the moment when onCreate/(or onUpdate) would be called."
"Thus when the Fragment is created, we already have a full working Activity with a working view."
"It will then call onCreateView and even onActivityCreated, even though the Activity hasn’t yet had it’s view inflated and setup."
"The solution for this, is to check in the onCreate function of the Activity, if it is being recreated, by checking if the savedBundle passed is not null, and not using an AsyncLayoutInflater in that case."
"To do this, you will assign the AsyncLayoutInflater.OnInflateFinishedListener instance to a variable, and call it directly after inflating the View."
You are attempting to access a widget before you have called setContentView().
"my Activity A's onCreate / onNewIntent, by providing a Bundle"
my first target Activity or building the stack myself inside of
"Thanks Dennis and Kaze, my android application is loading the default shared preferences from xml file with help of addPreferencesFromResource(R.xml.pref_general) in SettingActivity which extends PreferenceActivity which is a separate activity and it is started when someone clicks on Settings button hence the shared preferences are never populated before pressing settings button."
Your question about populating default preferences made me look into how is it populated and it should be populated in ForecastFragment onCreate using PreferenceManager.setDefaultValues as below ...
"Write the code below to update data from activity to fragment, This is to be written in Activity"
The services variable is not in the scope of your onCreate method.
"As mentioned by @Code-Apprentice, you might want to find out more about scope of local variables."
Initialize your adapter and set it to RecyclerView from onCreate() method.
You're getting this error because you call this.getApplication() inside the View.OnClickListener.
"To do what you need, just create a Context object outside of the listener in your activity's onCreate method and assign this to it."
"Because of this, this now references the listener and not the activity."
"First, you may wish to read more about what recursion means in computer programming."
"Moreover, you do not need to call those, as you are given the SQLiteDatabase, and so you do not need to call a method to retrieve it."
"Not an answer, but I have too much to share for comments..."
"Despite that, a notification sent from the Firebase console (with no data values) appears, and when touched invokes my launcher activity."
"You can run scripts after database is created or run every time database is opened using RoomDatabase.Callback, this class is available in the latest version of the Room library."
You need to implement onCreate and onOpen method of RoomDatabase.Callback and add it to RoomDatabase.Builder as shown below.
There is a ContentProvider called LifecycleRuntimeTrojanProvider that is merged into the app's AndroidManifest.xml.
"In its onCreate method it initializes a singleton called LifecycleDispatcher, which is responsible for updating all LifecycleRegistry instances."
LifecycleDispatcher uses the Application.registerActivityLifecycleCallbacks method that has been around since API 14 to get notified when a new activity is created.
It seems like the issue isn't in the onCreate method.
Note that the code should always be placed after the super methods.
"The system calls onRestoreInstanceState() only if there is a saved state to restore, so you do not need to check whether the Bundle is null."
You can avoid these issues by properly adding / removing your shorter lived objects (e.g.
"Why this issue is happening is because Android framework can't guarantee your service get started within 5 second but on the other hand framework does have strict limit on foreground notification must be fired within 5 seconds, without checking if framework had tried to start the service."
"startForeground a notification must be in both onCreate and onStartCommand, because if your service is already created and somehow your activity is trying to start it again, onCreate won't be called."
notification ID must not be 0 otherwise same crash will happen even it's not same reason.
Call startForeground() in onCreate() for the Service which you use Context.startForegroundService()
I've been researching this issue and this is what I've discovered so far.
It means that MyForegroundService didn't have a chance to call startForeground which will cause the crash.
To fix this we have to make sure that bringDownServiceLocked is not called before onCreate() of MyForegroundService.
By using sticky broadcasts we make sure that the broadcast doesn't get lost and stopReceiver receives the stop intent as soon as it has been registered in onCreate() of MyForegroundService.
What we did in our app was that we call WebView.setWebContentsDebuggingEnabled(true); inside the onCreate method of our MainActivity.java (found at android/app/src/main/java/com/[appname]).
I'm not sure it has an onCreate method out of the box so you may have to add one or try it elsewhere - we must have read the same article as I had previously done as you had and moved the call into the onPageStarted method of ReactWebViewManager.java but that didn't work for me either.
setWebContentsDebuggingEnabled is a static method of android.webkit.WebView so just make sure you have that import.
"It looks like all you need to do is add each Fragment to the back stack on each FragmentTransaction, and then pop each Fragment from the back stack in onBackPressed()."
Or tell compiler that count will be initialised later in this code by using Delegates.notNull check notNull.
"Use this only if you have an intensive (Some calculation/Inflating a layout etc) task that you want to do on demand, Not to just assign a value."
"It's there precisely for classes like Activities, when initialization happens in a separate initializer method, later than the constructor being run (in this case, onCreate)."
"Marking a property lateinit allows you to make it non nullable, but not assign it a value at the time that your Activity's constructor is called."
"If the property is read before a real value is assigned to it, it will throw an exception at runtime - by using lateinit, you're taking the responsibility for initializing it before you access it for the first time."
"The first time you access the button property, it will execute the block once and use the result for future calls."
"You do however, in this case, take responsibility for initializing the variables before using them the first time, otherwise you'll get an exception at runtime."
"The onCreate method deals with all the important stuff like setting the adapter, inflating the layout and setting onClick events for the items and a onTextChange event for the search field."
You can of course use anything you like as data types.
"With expandAllGroups() you can simply expand all groups, because they are collapsed by default."
You have changed the database structure while app is already installed but onCreate will only be executed once so you have two option to make your changes reflect into database
Manually uninstall the app from your phone to execute onCreate
"Initialise it in the onCreate(), or onAttach() method, so getActivity() doesn't return null."
"Handle onCreate, onDowngrade and onUpgrade methods in the implementation of your SQLiteOpenHelper class."
"In your onCreate method, right after you create tables, get all your data from Realm and insert into into SQLite tables."
You are initializing sharedPreference object before activity lifecycle could begin.
"You are welcome to register a receiver with LocalBroadcastManager in your Application (e.g., in its onCreate()), but I suspect that there are better solutions for whatever problem you are trying to solve."
"  In the actual app, the local broadcast will be sent when my IntentService completes its work"
You can add another item inside your menu.xml for your gridView Then create a boolean that carries the visibility of this two items.
2. you have to setHasOptionsMenu(true); inside your onCreate in your Fragment
The problem came because I did not notice that onCreateOptionsMenu and onPrepareOptionsMenu were not used so I deleted them.
"There, I did not have any problem to hide my menu item succesfully."
"When you want to use  SQLite database, make sure you have this line"
Make sure you are correctly setting adapter in activity lifecycle callbacks (i.e.
It seems to me you are creating and setting adapter after some action/callback.
"At first, Declare  BroadcastReceiver as Global &amp; You should call below in onPause() Method"
"in onCreate() of DetailActivity, postpone transition until indicator is laid out."
In onCreate() method of SettingActivity add general fragment and do the changes whatever you like in GeneralPreferenceFragment
You are calling getInfo(); in onCreate() which in fragment lifecycle called before than onCreateView()
You can also perform binding on arbitrary objects by supplying your own view root.
First of all let's understand what's going on with the documentation you quoted.
"Whatever your definition of ""resources"" is, neither onCreate() nor onResume() should allocate these resources."
"Corollary: As pointed out by @Juan in his comment, the above important note has an equally important, but not so evident corollary: onStart() should be the only method in which resources are being allocated."
"Assuming you have a View which is position on top left corner of screen, we want to animate it to the centre of screen."
Move the code in onCreate() that uses mCurrentUser into the listener.
"You should really remove the public static void main(String []args), it's not needed in Android."
"That's why the compiler is complaining, you're putting a method (onCreate) inside another method and you don't even need the latter"
"After checking the docs a bit more, it looks like you're falling into this scenario from the onCreate docs: https://developer.android.com/reference/android/app/Activity.html#onCreate(android.os.Bundle)"
"  You can call finish() from within this function, in which case onDestroy() will be immediately called without any of the rest of the activity lifecycle (onStart(), onResume(), onPause(), etc) executing."
FIX: Override onResume and call videoView.start in there and override onDestroy and onStop and call if (videoView.isPlaying()) videoView.stopPlayback in there
"You're calling unregister() in onStop(), so you do not receive events when MainActivity is in the background."
"To receive events even when the Activity is in the background, you should register in onCreate() and unregister in onDestroy() (rather than in onResume()/onStop())."
"While it was true that all my background tasks did call realm.close(), one of them called it too late in it's lifecycle."
"The problem was that GPS service is initialized at the launch of the App as an Android Service, which is rarely destroyed."
After the comments of @EpicPandaForce and reading his articles about using realm properly.
If You Are Using Intent Than Make Sure You don't Call finish(); After Using
For That You Have to Give Back button into Action bar.
The crash is happening because you didn't specify the activity layout before Button but1 = (Button) findViewById(R.id.but); in onCreate.
You are getting a NumberFormatException because you are trying to parse an empty String at the start of onCreate.
In order to fix this move your parseInt into the click listener of b1 like this
Calling getOverflowMenuButton(activity) will return null in onCreate because the overflow menu isn't laid out yet.
Set a value in Shared Preferences that keeps track of whether the app is on its first run or not.
"The setContentView() call you have in onActivityResult() is replacing the layout you've setup in onCreate(), so those Button instances that you set the OnClickListeners on are gone."
"You should initialize your imgN Strings inside the onCreate method, otherwise you're doing it prematurely, and I assume you're getting NullPointerExceptions somewhere in those calls."
"The Intent is only available from the onCreate method and onwards, right now you're trying to access it at the time when the constructor of the Activity is running."
"In the onCreate() method of your launch activity, you can check whether the device is running on an emulator and, if it is, just call finish()."
The token is often retrieved in the onCreate() of your initial activity.
1) You cannot use android.app.ListFragment with SupportFragmentManger you can use getFragmentManager() for that.
2) getListView() can't be called from onCreate because there is no view yet.
You are missing the run-time permissions introduced from Android Lollipop.
To clean up media player after each use you should call
In your case add this code to onCreate for every mediaPlayer you use.
The SQLiteOpenHelper will call the different lifecycle methods based on the version number that you pass in via its constructor.
SQLiteOpenHelper#onCreate is called only when there is no database available that the location specified.
It will compare the last version number that you passed in.
Most tutorials generally show a clear tables operation and a manual call to onCreate().
Now add some logging to the onCreate() and onNewIntent() methods and do some scenario testing.
Update : you are initializing the songProgressBar reference from XML using findViewById so you don't need this part at all
Camera app takes a lot of memory and on low-end devices with less memory system might kill your app to free some memory.
"You should implement correctly activity life time cycle functions, by saving instance state in onSaveInstanceState and recreating it in onCreate."
"The correct Android way to save state is by keeping the state in an Activity or Fragment, saving it appropriately in onSaveInstanceState(), and restoring it in onCreate()."
"If the system decides to kill your app in the background, then your singleton memory object will be destroyed, and your user will have lost all of their progress."
All of the Fragments in the ViewPager can get a reference to the parent Activity via a call to getActivity().
The onTokenRefresh() method doesn't trigger the first time an app Is installed.
"To get your token, you have to call FirebaseInstanceId.getInstance().getToken() at the start of your app (like in onCreate or something)."
"To start an Android activity, you need to create a custom native module."
"BreakIterator can be used to find the possible breaks between characters, words, lines, and sentences."
Just adjust the first part to change the text and type of BreakIterator.
I'm using System.out.println rather than Log so that it is also testable in a Java only environment.
onResume() is called every time your activity returns to foreground.
"You should instantiate your fragments, create an adapter and populate your viewpager with the adapter only once (onCreate() would be the spot)."
"If one of your users, for example, presses the home button and returns to your app then getStoreDetails() will be called again and you'll create a new adapter (with the same old fragment list) when the result arrives."
When new data arrives from getStoreDetails() just update the already added fragments with the new data.
You need to save state of your view model by overriding of method onSaveInstanceState()in your activity class and restore it in onCreate() method.
"More information about ""save-restore"" technology you can read at this part of documentation"
"When you call session.checkLogin() from your onCreate method inside  MainActivity, as the user is not logged in, you are starting again MainActivity, and then you are showing again the Toast and again you call session.chechLogin(), and so on."
Call the method to show the notification right in onCreate().
After a bit of investigation it turns out that notifyItemChanged only works when RecyclerView is attached and actually has completed onLayout which happens after onCreate.
"internally during RecyclerView.onLayout() which is called by notifyItemChanged -&gt; requestLayout(), processAdapterUpdatesAndSetAnimationFlags() is called which checks if the item that is to be updated has an available ViewHolder which in this case is null because during onCreate(), RecyclerView is not attached to the window, thus no measurement and layout has done to RecyclerView"
Apparently complete drawing of RecyclerView happens sometime after onCreate() and OnResume()
"I'm assuming this can only happen during onCreate and onResume, it may not happen if called later."
It happens because you don't setup default schema configuration in your application onCreate() method.
You have to call test.getWritableDatabase() otherwise the onCreate() callback won't be executed.
"The first time this is called, the database will be opened"
"Your BatteryChecker can implement ActivityLifecycleCallbacks and call registerActivityLifecycleCallbacks in onCreate when you create your Application class, in this case your custom class will receive all Activity lifecycle callbacks."
"It's of arguable benefit because you still have to use Activity events, but you could attach to the Activity lifecycle in your activity's onCreate() and detach from it in its onDestroy() events too."
"In the activity, you save the fragment's instance in onSaveInstanceState() and restore in onCreate()."
"Assuming an application with 1 activity, this is the longest lived object"
"Your activity instance is created, and is then called with onCreate()"
"sBackground is null, and so you assign it the getDrawable() result"
"A new activity instance is created, and is then called with onCreate()"
"sBackground is not null, and so you leave sBackground alone"
"In case of a Xamarin.Android App, you can put this in the Custom Application class onCreate method."
"Ideally, you would like to do this in someplace which is executed not more than once during the execution of your program."
add your package name and call this function in onCreate() of your Mainactivity
"The intent android.nfc.action.TAG_DISCOVERED, just as all NFC intents, is an activity intent and not a broadcast intent."
"Most of your application code will run here onCreate, onPause, onDestroy, onClick, etc."
There's not enough code to understand what's actually wrong here.
  by passing the ListView or GridView to registerForContextMenu().
You need to inflate the view while creating the context menu.
"  When the registered view receives a long-click event, the system calls"
That depends on whether a new instance of the main activity will be created.
"In that case, the new instance of the main activity will be called with onCreate()."
The original instance of the main activity is left alone.
I've had the rare IllegalArgumentException with Unknown URIs issue when I was doing ContentResolver operations in the custom Application object.
"Because you're calling cancel() in onFinish, the timer won't stop when the user clicks the button."
"To fix this, I'd suggest making a global instance of a CountDownTimer object, instantiate it in the onCreate method, and cancel it in the onClick method."
"In your code, assuming your app does get to the if you mentioned in the question when it should - remove the fastItemAdapter.clear(); and instead of the for loop with the if inside it write"
(Assuming here that GRModeClass is your items' class and that the long ms is the long you referred to that should determine whether the )
"When you rotate the first time, the field (imageUri) is set."
"Now in landscape, you'll read from the bundle in onCreate() and get the value you stored."
"onSaveInstanceState() will persist this field on rotate, in the bundle."
You can solve by removing the field myUri and assigning the value from the bundle in onCreate() to imageUri.
"You do not have a minimal, complete, and verifiable example here."
The correct place to call injection inside a Service is onCreate()
Note that in both cases the request for injection comes before the call to super.onCreate().
"  It is crucial to call AndroidInjection.inject() before super.onCreate() in an Activity, since the call to super attaches Fragments from the previous activity instance during configuration change, which in turn injects the Fragments."
"In order for the Fragment injection to succeed, the Activity must already be injected."
"For users of ErrorProne, it is a compiler error to call AndroidInjection.inject() after super.onCreate()."
The Activity super.onCreate() call re-attaches Fragments from a previous instance
"Fragments should be injected after their Activity is injected, therefore request injection in your Activity before calling super.onCreate()."
You can always check where to inject by looking at the relevant source code for the com.google.dagger:dagger-android classes like DaggerFragment and DaggerService.
When you are using Dagger 2 in Android you need to be very careful to make sure that your injected members track the lifecycles of the injection targets correctly.
A single FragmentManager will become available to an Activity some time after onCreate() and will follow the lifecycle of that Activity only.
"In other words, when that Activity is destroyed then the FragmentManager is unavailable for use."
You're creating a new instance of ListMovieFragment and then apply transition logic to it.
Short answer: add it to the onResume method and remove it in onPause method.
"Fragments are managed by the FragmentManager, which in most cases keeps an instance of the fragment so that it doesn't need to create a new fragment every time you want it to be shown."
"Active Fragment instances are automatically recreated when the Activity is, which happens by default upon an orientation change."
"Effectively, each time you rotate your device, you're adding one more Fragment to the stack, and the shadow gets a little bit darker."
"In the example Activity's onCreate() method, we add a dynamically created Fragment with the given layout, as described above."
"At the end of that sequence, we have eleven Fragments in play."
"The lifecycle methods of the service onCreate(), onStartCommand(), onDestroy() are all called on the main (UI) thread."
"Override onCreate() and make note of the current time (e.g., SystemClock.elapsedRealtime())"
"Register that custom Application subclass in the manifest, via android:name on the &lt;application&gt; element"
Because every time your start your app preparedata will be executed and same data will be inserted into data base and later will be displayed by Recyclerview.
if you want to insert your data only once then you should do this inside onCreate of your databasehandler
A 'better' way would be to create a Service which connects/reconnects to the MQTT Broker.
"If the service is alive, calling startService(..) again would trigger its onStartCommand() method (and not onCreate())."
Service runs in the background and is always connected to receive notifications.
"In this method, we simply check if this client is connected to the broker and connect/reconnect if required."
It comes from the TABLE_DAY array you initialize in your SQLite helper onCreate().
You could move the TABLE_DAY init from onCreate() to e.g.
You register the receivers in onCreate() and then again in onResume().
What you should do is to create one instance of each BroadcastReceiver in onCreate().
You don't need to create new instances of the BroadcastReceiver every time.
"However, if the data you want to receive comes from the network, then it will be obtained on a separate Thread (as no network calls can be done on the main Thread)."
"A solution would be to obtain the piece of data before you start the Activity, pass it in the Intent as extra and then retrieve in onCreate() using getIntent().getStringExtra()"
In this situation the layout will almost certainly display before the data is obtained.
at last add these lines in onCreate method of Activity
The best place to initialize the Ads SDK is from the onCreate method of your Application.
You can only use your activity as a Context with Resources in onCreate() or later in the activity lifecycle.
You're trying to use two layouts in the same activity.
"activity_main.xml is loaded in onCreate, but it doesn't contain a Button with id save_button."
Make a parent Activity and call setTheme() with date checks in it's onCreate() function.
Extend all other activities with the parent activity and don't forget to call super.onCreate() in the child activities that are extending the parent Activity.
There was a change in the latest Cast SDK that made it incompatible (crashing) with older versions of Google Play Services.
Create ViewStub in your layout pointing to MiniControllerFragment and inflate it only when you have play services.
The key here is that you can't commit a transaction after a call to onSaveInstanceState() and prior to a following onStart() or onResume().
You can commit transactions just fine on the initial onCreate() and a subsequent onStart() or onResume() because there is no state.
The easiest way to check for this scenario is to check if the savedInstanceState bundle passed to onCreate() and other lifecycle methods is null.
"If it's null, there is no saved state and you are safe to perform your transaction."
The back button should already be present without you adding it.
"When clicking on a Notification on System Tray, it will open the Launcher Activity and You need to Override onCreate() of your Launcher Activity to get the data extras and redirect user to the desired Activity."
Below is the example of a body of such HTTP POST Request.Example of a body of such HTTP POST Request is shown below.
"Below is the code, you have to write in onCreate() of your Activity to redirect user to the desired Activity."
"Ted Hopp's answer managed to solve the problem, but he didn't address the question of why this occurs."
Call the above method before calling setContentView(...) in the onCreate() method of all your Activities.
"First, reset the default locale manually in every Activity, or at least every Activity that has a WebView."
The locale parameter should be the default Locale that you wish to set.
"in the onCreate() of your Application class (if you have one), and wherever else the user may be changing the language."
Your code seems to be setting the locale in the configuration for the app itself (MyApplication.getInstance()).
"setupCamera() is called right from onSurfaceTextureAvailable, which can be earlier than the permissions are granted."
If they will be denied while in background your Activity will get killed and you will go through onCreate() again.
The NPE occurs because you have defined a com.github.jorgecastillo.FillableLoader in your R.layout.activity_splash but you haven't programmatically set the generated path.
"Note that you have defined a FillableLoader both in your layout and programmatically, but the definition that is causing the NPE is the one in the layout because it lacks the setSvgPath."
Note that in both cases you will need to call fillableLoader.start(); to see the animation.
It seems that the theme is set in activities but not in services.
"To programmatically specify one, add this in the service's onCreate method."
It will fix your specific error but the app will not run as-is.
"onCreate(Bundle) is used for initialization mean where your all UI initialization like view are done ,docs link for depth details"
"onCreate(Bundle, PersistableBundle) as it, itself suggesting , it is used for persistent mean reuse the old intent (supplied first time to this activity) while recreating it , you can enable reusing by adding a persistableMode flag to your activity so that activity will be persisted across reboots ."
"Note : You can only use onCreate(Bundle, PersistableBundle) in API level 21(Android Lollipop 5.0) or above."
First of all in color.xml define your colors and create array of it.
Add Shortbread.create(this) in the onCreate() method of your Application or MainActivity and you're done.
"In your onCreate method, you call the OpenCVLoader.initAsync method twice, first time after setContentView, second time in the if statement after the Log.i(TAG, ""Trying to load OpenCV library"") message."
"You should only call the OpenCVLoader.initAsync method once, many of the examples that come with the OpenCV4Android SDK do this from the onResume method."
Location permission privacy change in Android 10 or Android Q.
You need to actually request the Location permission at runtime (notice the comments in your code stating this).
You can then use onResume() and onPause() exactly as it is in the question.
  Although you can use the DSL directly (in onCreate() or everywhere
"  else), without creating any extra classes, it is often convenient to"
"In Android API 23+ there is a new way to handle permissions considered as ""dangerous"", that´s the case of android.permission.ACCESS_FINE_LOCATION and android.permission.ACCESS_COARSE_LOCATION among others."
After adding this line at the end of the onCreate() method you should start seeing the location updates in your log.
Basically you are not registering the listener to receive the location updates.
The problem is that MainActivity is a subclass of IntroActivity.
"When MainActivity executes, its onCreate() method is calling super.onCreate(), which is IntroActivity's onCreate(), where you're starting MainActivity again, calling super.onCreate(), etc., ad infinitum."
"It doesn't seem that MainActivity really needs to extend IntroActivity, so just make it a regular Activity subclass."
You can't run code other than primitive assignment in the class body.
Pull the value for the logic field from the activity in the fragment's onCreate() or other similar early lifecycle method.
Call setRetainInstance(true) to make the fragment instance survive some cases where reinstantation would normally occur.
When the orientation change then the state of fragment will be changed.
You need to save the state of your fragment by calling
You can also use onRestoreInstanceState() method which will store your savedInstanceState
Meaning you'll go through onCreate and onRestoreSaveInstance and so on.
Do not keep activities : Activity is destroyed and recreated.
It's pretty much the same behavior as a change of configuration like rotating the screen.
Calling Activity.findViewById() will look for the View in the layout of your Activity (the one you've set by calling setContentView() in onCreate()).
Intents using Kotlin for Android are almost same we just need to change slight in the syntax as below.
"Exception that you are getting is null pointer exception in your onCreate method on the activity, please check the same.."
"Correct me if I'm wrong, but it should not call onCreate() here's a gross over simplification, but let's say activity's are managed much like a simple stack, let's call it AppStack"
"When a onCreate() for Activity A is called, the OS pushes the Activity Instance onto the AppStack"
"When you click a button on Activity A, it launches a new intent to Activity B"
When Activity B's onCreate() is called the OS pushes that Activity Instance onto the AppStack
"Now if you call finish() or super.onBackPressed() in Activity B, the OS will  pop() the Activity from the AppStack"
You'll get a very specific UninitializedPropertyAccessException if you try to use this variable before initializing it.
"You invoke the method getResources() as part of the class initialisation (outside of any method, so it will be executed as part of the constructor)"
"Your Student_XML2WAY.java won't work with 2-way Binding, since it does not fulfill the requirements to do so (BaseObservable, Bindable or something like that)."
"If implemented correctly, this will also change the Age in your UI (as well as in your model)."
"In an IntentService, you're supposed to treat the onHandleIntent method like the doInBackground method of an AsyncTask."
"onCreate runs on the UI thread, so your initialization of the Realm happens on a different thread, which is a no-go."
You should not be calling close() on the SQLiteDatabase passed to you in onCreate() as you don't own it.
line causing issue because calling getActivity() at class level will return invalid Activity Context.
"I've made a change, so you should conveniently access the saved value."
The context should be this accessable within the onCreate method.
"In onCreate() of this new Activity, check if this Activity is the root of the task using isTaskRoot()."
"If this Activity is the root of the task, this means that the app was not active prior to launching this Activity."
You should be getting a java.lang.NumberFormatException because as soon as the app starts you are getting the string from edittext in onCreate().
"As with lots of things in computer programming, there is no single ""correct proceed"" for the timing of closing a SQLite database (via close() on SQLiteOpenHelper if you are using that, or close() on SQLiteDatabase otherwise)."
"If only a single component uses the database, there is nothing wrong with triggering opening the database in onCreate() and closing it in onDestroy()."
"However, there is nothing especially wrong with the open-use-close approach if you are sure that only one thread at a time will be working with the database."
"After all, if that is the only component that needs the database, you do not need the database when the component itself goes away."
"What you can do is control the rotation with a flag, and if onConfigurationChanged() is called, you can call the Activity's onCreate() yourself."
"If not, onCreate() will be called only when the Activity is first instantiated"
"The problem here, as you mentioned in the comments, is that the code that triggers the request permission dialog is being called in the onResume method."
"Moving this permission request to onCreate, or some other flow will solve your problem."
"In your case, refusing the permission would trigger a call to onResume again, which would once again display the dialog and cause an endless cycle."
"User returns to your app (by starting it again or selecting it from ""recent task"" list"
"In this case, there is no instance of ActivityA anymore."
"In Android we can't construct Activity or Fragment ourselves, therefore we perform DI in onCreate(), onAttach(), onCreateView(), etc., but it does not mean that we should be using DI libraries in order to assist in controlling the flow of applications."
DI libraries should be used in order to satisfy objects' dependencies at construction time.
To stop pausing of music when app gets to background.
Inside onCreate initialize list and adapter and set the adapter.
"calling SetContentView() does not create your app, so all the code you put in your onCreate() wont be called the second time."
You have to upgrade your database version in onCreate() and then use onUpgrade().
"Note: I am not an official Realm person, but I've been using Realm for a while now."
"When you call realm.close() on a particular Realm instance, it invalidates the results and objects that belong to it."
"(It's not as important to close the Realm instance on the UI thread unless you intend to compact it after all of them are closed, but you have to close Realm instances on background threads.)"
"Note: calling RealmConfiguration realmConfig = new RealmConfiguration.Builder(appContext).build() can fail on some devices if you call it in Application.onCreate(), because getFilesDir() can return null, so it's better to initialize your RealmConfiguration only after the first activity has started."
"When you finish and close your app, the state of it disappear in that moment."
"Nevertheless, if the text it not too long I recommend you to use SharedPreferences instead of OSW, because It quite easier to implement and It uses less system resources."
In Android the Looper is a queue system that runs a message loop.
"You have declared a global variable named builder, then you declared another variable inside your onCreate()."
"In your checking() method, it refers to the global variable which you didn't initialize, only declare."
The same problem happened to me and at this point it has nothing to do with the transparency of the AppBarLayout.
Step 1 can be easily achieved by adding this to your onCreate()
adding a space element to your NestedScrollView with the size of the AppBar
For Step 2 you need to add an empty view with the height of the appBar as a spacer to your NestedScrollView.
Headless fragment is nothing but a fragment which does not have a view.
"In onCreate of the activity, you have to add the fragment with a tag."
"Before adding, check if the fragment exist using getFragmentManager().findFragmentByTag(TAG), if the fragment is null then create a new instance of the fragment and add it."
"In Fragment there will not be any view inflated, so no need to override onCreateView()."
My problem got solved by putting all the code of onCreate() to onStartCommand().
We can create multiple threads inside the Service which will be executed simultaneously.
"When a service is called for the first time, onCreate() is called and after that, it's not called anymore no matter how many times service is called."
"On every service call, onStartCommand() is executed which creates new thread every time."
"For screen reporting, you do not need to call FirebaseAnalytics.setCurrentScreen() in every Activity because this is done for you automatically."
"Presumably, for this to work, you need to call FirebaseAnalytics.getInstance() in your Application subclass onCreate() method."
"ViewPager loads the next fragment for smooth transition between fragments, and that's why your next fragment's onCreate(), onCreateView() and onResume() is getting called."
you don't need to setAdapter every time your data changes.
you create an adapter once (in your activity onCreate() ) and every time your data changes set data to adapter again and call myAdapter.notifyDataSetChanged();
"The problem is that you're trying to use the Activity's FragmentManager, and you should be using the Fragment's child FragmentManager."
"Just add this line in your onCreate, When this option set the window not adjust for a shown input method."
"You need to have a FragmentActivity to get a FragmentManager, which means you cannot accomplish it in Application level, because it's too soon."
Below are two ways to send Activity instance/reference to Java plugin that doesn't use the onCreate function or extend from UnityPlayerActivity.
"Create your dataset list as a class variable and initialize it before onCreate() like this,"
You can initialize the library in your Application class in the onCreate method just like it is recommended in the README.
You've got the correct id but you're missing one very important line - setContentView.
That line binds the xml with the Activity's view and it's the view that's being used for findViewById.
"first you register an OnGlobalLayoutListener so you will access the dimension of the view in the right time (I believe you already know it), then you compute wRatio(width ratio) and hRatio(height ratio) using provided parameters and choose the bigger one as the scaleFactor (so you make sure that drawable covers whole of the view), Also you need to align drawable center horizontally (that's the role hTranslate plays), finally create the matrix and we're there!"
"In your activity's onCreate() method, check if the activity is newly started or is it being re-created by the system."
Add your fragment to it only if it isn't being re-created.
"Honestly, I don't think that update an Activity that is in background is a good practice (even if possible)."
"If app was only stopped, you can update the Activity content during onResume() method."
onCreate() is called before the View is displayed to user.
View decor = getWindow().getDecorView(); this decor view used to get the default action bar.
"To prevent flickering for action bar, status bar and navigation bar."
"the documentation of the onCreate(android.os.Bundle, android.os.PersistableBundle) method that is being overridden in MapActivity suggests that persistableMode for the activity in the AndroidManifest.xml needs to be set to persistAcrossReboots for it to be called...but MapActivity is abstract, so you would need to set the attribute for its subclasses instead."
The easiest solution for this problem is to scroll down to the bottom of the grid and then back up to the top.
Declare ArrayList&lt;String []&gt; al = new ArrayList&lt;&gt;(); outside the onCreate function.
"If everything is working fine for you but you just need the image to fade as the AppBarLayout collapses, you can set up an addOnOffsetChangedListener that will detect how much the app bar has closed."
"Whenever the OS needs to re-layout your view, it will call onCreate and onCreateView with a saved instance state."
in your onCreate() of your activity and you'll now have just one list displaying.
Possible workaround is to use onStart/onStop to  add/remove change listener.
"If it is your own service, you know whether your service exists."
"Validate the signing key of the service, so that I know that it is not some service that is masquerading as the one I want to work with (e.g., repackaged app with malware)"
For an Activity the sort of equivalent method is onCreate().
You are trying to access the context required in getResources() before the fragment is instantiated.
You should do in onCreateView()after your inflate your view or in onCreate() like this-
block the UI (perform work in onCreate) - another bad practice
"perform the work that you'd do in onStart later, i.e."
  onCreateThumbnail - Generate a new thumbnail for this activity.
"In the onCreate() method of your Activity, instantiate a LocationAssistant with the desired parameters."
"For example, to receive high-accuracy location updates roughly every 5 seconds and reject mock locations, call new LocationAssistant(this, this, LocationAssistant.Accuracy.HIGH, 5000, false)."
The quick solution is to store it in sharedPrefs and add this logic to onCreate method in your MainActivity or class which is extending Application.
in your ContentProvider's onCreate() method because this method is called even before the onCreate() method of your launcher activity.
Add the following method in your activity class and call it in onCreate
"Your problem should be solved removing your android:onClick=""createNewTournament"" event from your layout"
The same problem happen in this question EditText OnClick Exception and was fixed using listener.
You don't receive the Event because ReceiverActivity haven't registered as EventBus subscriber.
It will unregister EventBus only when we finishing the activity.
"It is there to let you reuse event handlers like the OnClick method, the View parameter is in your case the Button instance that has fired the method - multiple Buttons can have the same OnClick handler, inside the method you can check which of the Buttons has fired (if there are more than one) and react accordingly."
"My favorite is thus the second one - it allows you to keep all the logic on one place in the code, for example if you register all you handlers in the onCreate method of an activity."
"The first is nice because you can set it visually, yet given that it is all in XML files and you could have multiple layouts for an activity it can be quite a mess to keep it under control in a larger project."
"It's gonna be a pretty good amount of code to add, but, here's what you have to do."
You want to show/hide the Login button base on the text of EditText so you need to listen for changing in EditText by use TextWatcher.
"Beyond any doubt, the problem is because you are changing transitionName of the view that you want to share from second Activity to third."
"Below is a chain of briefly explained steps that hopefully shed some light on the sequence of ""loading"" the system UI components at boot time."
SystemUIService is just an Android application component whose onCreate() method starts/initializes UI components and stores references to the components in the mServices[] array of SystemUI type.
"When SystemServer is ""done"" with the core system services, including StatusBarManagerService *, it informs the 3rd party code that the system is ready and starts the system UI (line 870), or more precise, SystemUIService in the com.android.systemui package **."
The 1st element (mServices[0]) is either the status bar or system bar (status + nav bar).
"Within the lifecycle callback methods, you can declare how your activity behaves when the user leaves and re-enters the activity."
"Remember that the way Android is designed, there is a lifecycle for each and every app."
"You are getting null values for your Location object because you are initializing an object every time the Button is clicked, and getting the values of that object."
You should also add an initial check in onCreate() to check for the location.
"When you get the coordinates to log them, you will not get a null value since you are setting them in your onLocationChanged() listener."
"After doing this, you should be able to write ""https://maps.googleapis.com/maps/api/geocode/json?latlng="" + lat + "","" + lng"" for the String you are passing to you JSONObjectRequest."
"It doesn't ""receive the bundle from onStop"", insofar as onStop() has nothing to do with a Bundle."
The Bundle delivered to onCreate() and onRestoreInstanceState() contains the data put in an earlier Bundle by onSaveInstanceState().
The content of that Bundle is passed across process boundaries to a core OS process that manages the state of outstanding activities and their tasks.
"Unfortunately, all processes in an Android app share a common Application subclass, so your onCreate method is run in the background process as well."
Crash Reporting creates a second process (background_crash) to send crashes.
"After adding some logging, I found that the fetch job's onComplete() was never being called."
"(Ian Barber, this might be something to look into or clarify, as the logs indicated that Firebase was initialized without an issue when it was in the Application, and the fetches were silent failures.)"
Just cancel all the notifications inside the main Activity's onCreate() method
"You initialize the other EditTexts but never C. So when you try to get the text, you get NullPointerException because you try to get information from nothing."
"In your image, you show that you are leaving input blank for one of the text boxes (in the ""after crash"" image, we see that you entered 3, 4, and then nothing)."
in your main activity onCreate method during first app launch to schedule this task for the first time.
In the tabs activity java – in onCreate moved to last page if the language was Hebrew.
"In PlaceholderFragment class both in onCreateView and getPageTitle checked if the language is Hebrew, and if so returned the views and tittle in reverse order."
If that's the case then add to the Activity's onCreate();
"In onCreate() you're starting an infinite loop inside of the UI thread, blocking it completely."
Your module and component would look something like this (maybe add some scope)
In your test activity implement your abstract method getLayoutRes();like below
With this approach you can add more activities which extends BaseActivity just implementing abstract getLayoutRes() method in.
"Without that line, the binds you set up aren't performed, and the views remain null."
"Your class which extends SQLiteOpenHelper should execute the sql command in onCreate method to create the table, like"
Yes It's for sure you have created command as final String DATABASE_CREATE_SQL to create table But forgot to execute this so that table is not created.
To make you notice your both onCreate and onUpgrade methods are empty.
The most basic thing to do is put this in onCreate()
You are attempting to call a method that you are inheriting from Activity from a field initializer.
"In general, do not call inherited methods on Activity until after super.onCreate() has been called in your onCreate() method."
"You are welcome to have a field, but do not initialize it until after super.onCreate()."
You would possibly have to reinitialize things in onCreate if savedInstanceState contains your data.
"Just don't use a static variable to hold the component, but make sure it lies within your activity or application respectively."
Just add ButterKnife.bind(this); inside the onCreate of your activity and then
You don't have to add this line @Bind(R.id.whatsapp) ImageButton ButtonWhatsapp;
"First of all, calling a web page and waiting for its response is NOT a good option when trying to determine whether there is or is not an available internet connection."
It will place your My Location button in bottom right.
The activity context is not created till onCreate() gets invoked.
There are two two things which have to be implemented here.
"Static method which you can pass necessary data to and get new instance of this class (Probably I could have just used a regular constructor, I'll have to experiment with it a bit more)."
An Activity is not fully initialized and ready to look up views until after setContentView(...) is called in onCreate().
Might not be part of the problem but as an extra bit of advice a Timer runs the TimerTask on a background thread and that should be avoided in this case.
"After that, onCreate() should no longer be called when plugging in the device."
"note that you shouldn't use that as a fix, it is just a way to make sure that this is the case for you (and it is not a specific thing in your code)."
"Although, note that you will frequently get null from the call to getLastLocation()."
onCreate won't be called if just onStop has been called on an activity.
"After onStop if user navigates back to activity, it's onStart (before that onRestart will also be called) will be called."
Now let me explain how onCreate will be called after onStop without onDestroy being called.
"That's why in the question image (activity lifecycle), it is shown that onCreate will be called after onStop if App process is killed."
It's much easier to illustrate with some sort of division of responsibility for your Activity and Fragment.
Probably worth having setRetainInstance(true) in the onCreate of your fragments as well.
The following line needed to be added to my Dialog's onCreate()
are in onCreate() they will be empty when the Activity first starts.
You can fix it by putting those lines in your onClick().
"To answer your question, no, you can't get a reference to the fragment's view in the activity's onCreate()."
The reason is that the fragment's view doesn't exist until the fragment has gone through it's lifecycle.
"If the fragment needs to communicate events back to the activity, have your activity implement a listener interface, and have the fragment call that interface when appropriate."
remove setcontentview from onCreate method you already set view in onCreateView
Instance member variables are initialized when the instance itself is initialized.
Before onCreate() your activity does not yet have a Window that findViewById() needs internally.
Before setContentView() (that you should be calling in onCreate()) there are no views to be found either.
Therefore init your view references in onCreate() and after setContentView().
You need to call your private method setSupportActionBar() inside onCreate().
"Most implementations will simply use onCreate(Bundle) to restore their state, but it is sometimes convenient to do it here after all of the initialization has been done or to allow subclasses to decide whether to use your default implementation."
"  This method is called after onStart() when the activity is being re-initialized from a previously saved state, given here in savedInstanceState."
onRestoreInstanceState guarantees you receive a non-null Bundle object also in the lifecycle of activity it's called after onStart
You need to use AsyncTask for loading data and RelativeLayout for displaying Rounding Circle in ActivityB.
"Can I assume, that onServiceConnected() is only called after all of my"
According to the service lifecycle diagram onBind() is not called until after onCreate() has completed.
The documentation states that the system calls onServiceConnected() to deliver the IBinder returned by the service's onBind() method.
Therefore onCreate() is completed before onServiceConnected() is called since it is dependent on the return value of onBind() which occurs after onCreate().
"You can also see this in the diagram where it says ""Clients are bound to service""."
Your XML for the MapView needs to be com.mapbox.mapboxsdk.maps.MapView not com.mapbox.mapboxsdk.views.MapView
"Lastly, make sure you include all the mapView methods within your activities lifecycle."
"getContentResolver() is method of class android.content.Context, so it definitely needs an instance of Context (like Activity or Service)."
you just add this style in your style.xml file which is in your values folder
Edit:- If you are going with programmatic way to hide ActionBar then use below code in your activity onCreate() method.
After that set this style to your activity class in your AndroidManifest.xml file
add this line of code in your onCreate() method or you can use above theme.
You are saving your ViewPager instance in a local variable in onCreate.
You can handle this by maintaining some state between the activity starting and stopping.
"Simply save whether there is a pending dialog already when onSaveInstanceState() is called and restore in onCreate(), and guard against calling the API again if so, clearing the state once onActivityResult() is received for the intent."
See use of the mIsResolving variable in this sample code.
The problem is with your override to the back press (which does not need to be overridden) and is likely a symptom of with what your activity does when focus returns to it.
"In response to your Edit 3 you need to make sure that LoadingPage has android:noHistory=""true"" so that it is not available to the backstack and then finish it explicitly to clean it up when you start the main class"
"That is because you are trying to call methods inherited from Activity, like getSystemService(), from a field initializer."
"You need to wait until onCreate(), and usually until after super.onCreate(), before calling methods like getSystemService()."
  Ive tried placing my code from the start in the onCreate() method but this doesn't work either.
The same principle will hold with onCreate() of an activity.
  When I try to place the (LocationManager)getSystemService(Context.LOCATION_SERVICE); in the onCreate() it requires a permission
"You need to have a &lt;uses-permission&gt; element in the manifest for ACCESS_FINE_LOCATION or ACCESS_COARSE_LOCATION, depending on whether you plan on using GPS_PROVIDER or NETWORK_PROVIDER."
Instance variables in Java are initialized when the instance is created.
"In case of activities, they are instantiated by the Android framework using reflection (see Instrumentation#newActivity())."
  I was able to get around it by saving the MapView's saved state on a separate Bundle and then adding it to the outgoing saved state bundle.
"My original answer dealt with the BottomNavigationView, but now there is a BottomAppBar."
We just add a listener to the Bottom Navigation Bar in our Activity's onCreate method.
"Yeh After Marshmallow come Android make security level more stick, But For"
you can show floating action and anything You can Force user to give permission for it By Following Codes in your onCreate() method
if had permit once don't drive him to Settings.ACTION_MANAGE_OVERLAY_PERMISSION and if has not permit yet then ask for runtime permission check
"As you can noticed, parallel tasks will run only on Honeycomb and above."
A mistake that confused me for a while was that I created an instance of IntentIntegrator in the onCreate() method of ScannerActivity.
One is the ScannerActivity and other one is the CallingActivity.
The problem is that shared element transitions is started by the framework very early in the Activity lifecycle.Transitions must capture both the start and end state of its target views in order to build a properly functioning animation.
"when you know for certain that all of your shared elements have been properly positioned and sized, call startPostponedEnterTransition() to resume the transition."
The second one will be created when the system eventually calls onCreate().
The Android system does this at some point during creation.
The gotcha would be if you had an object that needs a Context in the constructor.
You are trying to find the ListView element in your activity_main_screen xml where there is no such element.
"@AAG you were right, the exception handler was being added each time an onCreate() method in any activity was called."
"Remove android:editable=""false"" this line from android xml file as this method is deprecated in android."
In onCreate of activity do the following after setContentView() method
"Don't try to interact with the google map in the onCreate or some other starting lifecycle method, as the map is not instantly ready as soon as it is added as a layout."
When you define your class as a public class MyEntity implements Serializable you are basically defining that all atributes of MyEntity should be serializable.
"named CustomInterfaceImplementation ) in a separate file, and make instances of it, or make an inner class of your Activity which is static (note that this Activity will not be created inside your onCreate() method, because that wouldn't make any sense."
It should be created outside any method's scope and inside the Activity scope).
Remove public void onClickButtonListener() { and put button_cont_break = (Button) findViewById(R.id.Breakfast_continental); inside onCreate method.
"After merging the helpers, uninstall your app so that the old database file is removed and the onCreate() that creates all tables is invoked."
Note that onCreate() is only invoked when the database file didn't exist so the DROP TABLE is really not needed.
"You need to split your SQL to individual calls, one for DROP TABLE and another for CREATE TABLE."
"Because you have setRetainInstance(true), the Fragment is not destroyed/recreated on screen rotation."
"The Fragment will call onSaveInstanceState() after a screen rotation, but the onCreate() portion will not occur."
"First of all, I'd suggest you to not start variable names with capital letter: displayText instead of DisplayText."
Number three: onCreate method will get called only when your activity is first created.
"On Android 6.0, system's night mode setting defalut is UiModeManager.MODE_NIGHT_NO, it will change Resources.Configuration.uiMode before onCreate is called."
"However, support library apply its night mode setting in onCreate in AppCompatActivity, it's too late, I think thats why it not work on 6.0."
You need to initialize your views after setContentView in onCreate
"YouTubeBaseActivity extends Activity, (as opposed to, for example AppCompatActivity), so the getSupportActionBar() method doesn't exist."
Access it in onCreate() of your Activity in the same way you would any other static Fragment
"Add the following to your layout file, in place of a YouTubePlayerView"
You can add extras to Intents and check for them in the onCreate() of the called Activity.
"Let's assume that we have 2 Activities – ActivityA, and ActivityB."
"Now in ActivityB's onCreate() method, you can just check for the boolean value passed to the Intent."
I've passed a Boolean value of true because I intend to start the Activity with a SharedElementTransition.
"For your main problem, maybe you can check for the amplitude of the sound, and only vibrate if a minimum threshold has been reached."
"The ids don't match, you can't find the view and you get a NPE."
Don't call getWritableDatabase() or getReadableDatabase() from your SQLiteOpenHelper lifecycle methods such as onCreate() or onUpgrade() that are in turn triggered by a call to get...Database().
You also need to return ViewHolder as @Yasin Kaçmaz 's answer.
The main difference between getIntent().getExtras() and the savedInstanceState is that they have different usages.
"The point is when you load date from the internet you would have to wait just one time, on the second onCreate() call the data will been restored (if you show them in UI elements with an id!"
"Q3: No not necessary, that depends on your use case, however that would not break anything."
"If there's a problem, onCreate() must not return normally but throw an exception."
"After fixing the above, uninstall your app once more to remove the empty database created with your broken onCreate()."
Declare the variable outside the onCreate and initialize it inside the onCreate.
"That said, (since you're dealing with Activities) I recommend to store all persistent data as per the documentation, in onPause()."
One case of onRestart() being called is when user presses home button and comes to launcher screen.
"When user opens your app again, onRestart() for that activity is called before onCreate()."
"In this case, activity is not destroyed and pause/stop events are fired."
"Your method eventListClickListener() should only be called once in your onCreate(), not every time in your updateEventsHard() or updateEventsSoft()."
"As already mentioned by mklimek, onTaskRemoved() is the way to go for this."
don't use the new operator on a class that extends Activity.
"in your Service's onCreate you can retrieve the imei (you need the service to go through its lifecycle as well) and instantiate the Runnable , providing the imei to the constructor"
You need to be using an AsyncTask class to communicate with your server.
It's just a matter of invoking notifyDataSetChanged on it when task is completed.
I'm here to add my 2 cents because this is where I landed after Googling for that exact title.
As your Observable is not hot I would suggest you alternative and more simpler method: just subscribe and unsubscribe from your Observable.
"However, if you are only searching from MainActivity (hitting back on ListActivity after a search), then you are destroying the ListActivity instance and then creating a new instance - leading to onCreate() being called, but not onNewIntent()."
"singleTop only applies if the activity (in your case the ListActivity) is on top - instead of creating a new instance, it would reuse the existing one."
That's because the context has not been created yet when your initializer runs.
"Create your card, and add the MapView inside the CardView."
UPDATE: And i've seen few problems in the layouts and the ids.
"Generally speaking, you cannot call methods that you inherit from Activity (or subclasses, like AppCompatActivity) until inside of the onCreate() method."
"your class member context is null, because in onCreate, declaring"
you are hiding the visibility of the member class in favor of the local member.
in your values folder and in your values-sw720dp and values-sw600dp add the same resource with a false.
Make sure to add the appropriate libraries from RxBinding to your project for what you need to your Gradle build file.
The life cycle for a retained fragment is different as I'm sure you noticed.
onCreate of the retained fragment will not be called when the device is rotated.
I've been experimenting with Dagger and it definitely seems to blur the lines between service locator and dependency injection.
"With the current version of Dagger, it is possible to write AndroidInjection.inject(this) in an activity's onCreate method."
"That's basically like saying ""find all the services I need and inject them into me."""
"now to remove Notifications call notificationManager.cancel(String tag, int id) wherever you want like this"
The problem is that you are calling recreate() in the onCreate() method of the Activity without any condition which will create an infinite loop.
Keep a variable to track whether the activity is recreated or not.
Note that I'm importing  and overriding that client instead of creating a vanilla OkHttpClient since this is the one that React Native will use.
"Firstly, you need to add android:windowSoftInputMode=""stateHidden|adjustResize"" inside your &lt;activity&gt; tag, then you will see your behavior will work correctly, but you won't be able to scroll the NestedScrollView to the bottom fully."
"drawer is null, presumably because the DrawerLayout with ID drawer_layout is not in the app_bar_home layout."
The second call is completely replacing the activity_home layout with the app_bar_home layout.
"In general you should call cleanup() in the ""opposite"" method from where you create the adapter."
"You can't call getApplicationContext() before the onCreate() method is called, that may be why it's returning null and giving you this error."
"Thus, I suggest you set the field in the onCreate(), or better yet just use PreferenceManager.getDefaultSharedPreferences(getApplicationContext()) directly wherever you need to use the SharedPreferences."
Creates a new Application instance (which will call the constructor of that class)
"After that, Android then instantiates the necessary component (which calls the constructor for that component) and then calls onCreate() on that component."
"In this case, the Application instance already exists, so Android does not need to instantiate a new one."
"You are fetching value of e1 in onCreate(), while you want it when user click on button"
"Usually, in the case of onCreate it is enough to check that the activity is not being restarted, that is, check that savedInstanceState == null and only then add the fragment."
"Yes, if you just add the fragment on each call to onCreate there will be more than one instance."
You should not attempt to call getWritableDatabase() or getReadableDatabase() from SQLiteOpenHelper lifecycle methods such as onCreate() or methods called from there.
"Yes, it is possible to detect beacons in the background only after an Activity starts, but you still need to make a custom Application class that implements the BootstrapNotifier."
"The tricky part for your purposes is to figure out in the onCreate method of the Application class whether this this is an app restart (after low memory shutdown), or a first time launch of the app before the Activity has ever been run."
A good way to do this is to store a timestamp in SharedPreferences for when your Activity is launched.
An Activity's base Context won't have been setup until after onCreate() has finished executing.
Simply move the initialization of dpi to onCreate() after super.onCreate() has been called.
"Add it in your onCreate() method, after you initialise the navigation drawer."
"As a tip, don't forget put ButterKnife.inject(this); in a proper place like onCreate()"
"Because it uses annotation processing during compilation, there is no performance/overhead penalty during a runtime."
Because using Activity Context before creation of Activity at class level.
"What that boils down to is that you need to initialize filename in a lifecycle function, probably onCreate()"
"In other words, your Activity needs to be instantiated before you can use its super class methods, in this case getFilesDir()."
fix this by creating the polyline initially in your onCreate() method or somewhere else in the activity lifecycle.
First being that you are creating a new polyline every time the users locations changes rather then adding a new point to a polyline when onMyLocationChange() is called.
Once you created the polyline assign it a name and make it global.
"it seems that you are using  ParseUser.enableAutomaticUser(); ,remove this line of code from onCreate of"
Enabling automatic user creation makes associating data with your users painless.
In the Activity you are opening (that is behind the lock screen) you should tell system to lift the keyguard (e.g.
You can access the instance of the toolbar using views by id function
if your toolbar is inside other xml component (referenced with &lt;include/&gt;) you still can access it as long as you provide and @id to the &lt;include/&gt;
"You could just use View#findViewWithTag(""someTag"") to reference the view then get the id from the view."
Edit: If your in an activity (inside onCreate) you could get do this
In your Fragment you need to say that this Fragment controls the menu.
Now you can implement the following in your Fragment to hide the MenuItem you don't want.
Make sure you do the reverse in the Fragment you do want the MenuItem in.
"After you have both of those set up, you can then add this into your main onCreate()"
NOTE: Call this method before setContentView() in the first activity's onCreate() everytime when the app is opened.
Store the selected locale code in shared preferences and retrieve to pass as parameter.
"First, I have to say that this a really well formulated question and I would be happy that every guy with few reputation asks so good formulated questions."
The problem you encounter is basically an issue with the Android Activity lifecycle.
"(The code above is just to give an rough idea, I would be surprised if it compiles)."
"Of course, you can call this method also from the place where it was before (that is actually what happens if you literally extract the method Right-Click > Refractor > Extract Method)"
You can avoid this by doing the same lookup you are doing in your updateFragment method and only adding the fragment if it isn't found.
It is because in your BreakoutGame activity you have an empty constructor without any access modifiers (default is package private).
"Every initialization, yo want to do in your Constructor can be done in one of the callback called by the framework."
In your Long click method do something like below code
On your activity's onStop()  method try to save your data in SharedPreferences
"Call startForeground() with a valid Notification from a service lifecycle method (e.g., onCreate(), onStartCommand()) or a method invoked by one of those lifecycle methods (e.g., onHandleIntent() of an IntentService)."
To me looks like more some issue with the emulator.
"For step #2, you currently have code to drop your tables and go to onCreate() to build them again."
"As long as this value is greater than 1, then you have completed step #3."
"Now the important part, if the user returns to your app the Android system re-creates the destroyed Activity and passes a non-null ""saved-instance-state"" Bundle to the onCreate() method."
"If the Android system decides to kill your app because it needs to free some memory for another app, your objects will be destroyed."
"You might assume at this point (because the Bundle is non-null) your in-memory stored objects exist, this is however not true!"
"you'll see that once the Activity is shut down, it will be recreated from scratch, meaning that onCreate() will be called."
Extend just Activity instead of AppCompatActivity in your Java class and the toolbar would be gone.
"  However, if I try to create sharedPref in onCreate, it's only available in that method."
You are welcome to declare the data member outside of onCreate().
"Because you have used Volley library which is already asynchronous, you don't have to use AsyncTask anymore."
"P/S: since the reponse data is a JSONObject, so I suggest you use JsonObjectRequest instead of StringRequest."
By the field initialization code I mean the code between onCreate() and onKey() methods.
just try to take a screenshot in the oncreate the bitmap I get is empty.
"If, instead, you have the root View draw() to a Bitmap-backed Canvas, that might work already in onCreate()."
"Given the approach that you are using, you need for the framework to have actually drawn the UI before you can capture a screenshot."
"It depends on whether the root View has been called with measure() and layout() yet, and I'm not sure whether that happens already in onCreate() or at a later point."
"It looks like you didn't initialize your EditText, you need to add this line in onCreate before you call setText("""")"
Make sure you put this after you can setContentView though
"Turns out it was because I was initializing the RecyclerView after onCreate(), therefore the content view would skip the RecyclerView because there is no adapter attached."
"The solution is to initialize the RecyclerView in onCreate() with a null Adapter, then swap the Adapter when I receive the data."
You're trying to use view before it has been initialized.
EDIT: Looking at this some more what's more likely happening is that you're using your instance of onServerRecieve before view is initialized in onCreate().
You need to wait until after view = (WebView) findViewById(R.id.webView); has been called in order to initialize onServerReceive.
Your int variable is a member of your Activity class and you're checking it in the activity's onCreate() callback which is only called when the activity is instantiated.
Each instance of your activity is instantiated anew and member variables get their default values.
Well onCreate() is called when your Activity is created and you need to initialize some very important things of your application like your main layout!.
We need some more context to give you a straight answer.
Both methods might be called multiple times depending on what the user is doing.
To reference your Draw class create global variable  in your MainActivity
Have a look at the diagram for an Activity's lifecycle.
"The onCreate() method runs before onResume(), so your sending the broadcast before you've registered the Receiver."
"I'm not sure why you'd want to broadcast to the same class, but you can solve your issue by calling the registerReceiver() method in onCreate() as well, before the sendBroadcast() call."
Assuming that you have a DetailActivity and you need back button to MainActivity.
"Okay I think I understand now, you are using the method getIcon() but you never actually set an icon via setIcon() so you are returning null on getIcon()."
Maybe I'm missing something but I don't think you're actually launching your AsyncTask.
"As onCreate() of an Activity is called only once, this is the point where most initialization should go: calling setContentView(int) to inflate the activity's UI, using findViewById to programmatically interact with widgets in the UI, calling managedQuery(android.net.Uri , String[], String, String[], String) to retrieve cursors for data being displayed, etc."
It is inefficient to set the content in onResume() or onStart() (which are called multiple times) as the setContentView() is a heavy operation.
"The strategy is to obtain the ""Selected"" view and set its text color before onCreate finishes."
"When I tested it in the debugger, no UI is shown during the onCreate method, so this is guaranteed to work."
Create a LocalBroadcastManager object mBroadcaster = LocalBroadcastManager.getInstance(this); on onCreate of your GCMListener and send broadcast with
"You have access to the source code, so start with that."
"Setting some of the complexities aside, mGLThread should be non-null so long as setRenderer() is called."
Set a Dialog theme on the Activity in your manifest.
"In annotated Activitys, the @AfterViews annotated methods are called in onCreate()."
"In annotated Fragments, the @AfterViews annotated methods are called in onViewCreated()."
"However the main reason of AfterViews is getting a chance to the caller to initialise injected views, which are not yet available in onCreate()."
"After having discussed and tested various scenarios (refer to comments below the question), I've decided to combine and write up those results into an answer."
You can implement it yourself by adding a bottomsheet element to the parent layout of the MapFragment and then setting a custom OnMarkerClickListener.
The SurfaceView's surface is configured to use RGB 565 by default.
"Listen for ACTION_BOOT_COMPLETED as you're doing, along with other broadcasts."
"Or, without an Application class, stick the code below in each of your individual BroadcastReceivers."
"in onCreate the local variable packageManager, is hiding the one declared as member class, leaving it initializied, and causing a NPE addProximityAlert."
"I'm currently working on an app with some similar issues, here is what I've done."
Note that each of the Fragments I call exposes a public method that the Activity is expected to call.
Each dialog has its own Window which have its own style.
"In your case hideStatusBar() doesn't work because its called from activity's onCreate() it means it tries to change appearance of activity's window, but not the dialog's window."
It means you have to have a deal with Dialog.getWindow() rather Activity.getWindow()
"Whenever you try to get dimensions on onResume() or on onCreate() method, it always returns 0."
"In onCreate of the MainActivity, if there is internet access you will call displayView(0);."
You can pass the button caption to CadastroTimes with intent as
It seems that you initiate LocationQueries at the wrong place.
is called as a global variable in your Fragment class.
"Your configuration cannot be applied until your Activity is restarted,so when you click to change locale it cannot be applied at once,but when you rotate your screen the Activity restarts thus applies your configuration changes."
You can get the SharedPreferences and apply the locale in the Application class's onCreate() method.
"As for applying new locale in the future app opening,you can use SharedPreferences to save your configuration and get the locale value every time your application is opened and apply it."
In both cases you'll need to check your orientation and you can detect it in your onCreate() method.
"Using a RecyclerView will benefit you in the future if you wan to add more views to your layout, its easy and dynamic."
"OncreateView has return type of View, So you must return a view which attached to activity."
"According to the stack trace, you implemented a constructor on hesh.ballc.MainActivity."
"Whatever code you have in that constructor should go into the activity's onCreate() method, probably after the super.onCreate() call."
"There are few, if any, scenarios in which having a constructor on an Activity subclass is the appropriate thing to do."
"Your reference reads ""in at least one class"" and pertains to a standalone Java SE program."
"Your Activities will be brought to life by Android OS calling callbacks into your Activities such as onCreate, onPause etc..."
"In Android you, however, do not need main at all."
onCreate() is called before onCreateView() and therefore you will not be able to access it in onCreate().
my app doesn't show in the list of things I can share to
"Just don't call setContentView() in onCreate(), but instead do your work (e.g., kick off an IntentService to do your network I/O), and call finish()."
"You are welcome to use Theme.NoDisplay, Theme.Translucent.NoTitleBar, or something to have an activity with no UI, though."
you have to do something like this.. in Activity you Have to override
The root of the problem is how you maintain the reference to activity inside headless fragment.
"You can confirm this by logging the reference of activity inside onCreate: Log.i(TAG, ""onCreate: this="" + this); and inside activity’s method which updates UI after async task: Log.i(TAG, ""updating UI: this="" + this);"
There are 2 instances of activity after rotation in your case: the first - which is referenced by mRequest and the second - which is visible and active.
"If the headless fragment is not set to retain itself, then activity’s onCreate() recreates it in every call."
According to new design pattern in android studio activity_main.xml will determine how the look of the main activity should be.
"As mentioned before, the layout file used for your activity is set with setContentView(R.layout.activity_main); in the onCreate function of the activity."
"What this provides you is the ability to leverage the fact that a bound Service only lives as long as clients are bound to it, so you can monitor the onCreate() and onDestroy() methods of the Service to know when the current foreground task is not part of your application."
You might also find this article written by Dianne Hackborn to be interesting covering in more detail the Android architecture and how Google thinks it ought to be used.
"If that is tha case, than you should put all your code with the apropriates modifications in the implementation with public visibility and delete the implementation with the protected visibility."
The solution was in using the postponeEnterTransition() and startPostponedEnterTransition() calls to ensure that picasso has finished loading the image into the view before the activity starts.
Below is an example of what you might use in onCreate
In your fragments onCreate() method you can use setHasOptionsMenu(true) to allow your fragment to handle different menu items than it's root Activity.
"Application onCreate() is called when the application was dead, and it was started."
"From what I can see, you may call location1 and location2 when they are not initialised in your method startRepeatingTask()."
Declare PackageManager pm; Once in your class scope and then initialise it in your
"By declaring a PackckageManager pm = getPackageManager() within your Activity class and within your onCreate, do you realise that you are dealing with two separate instances with the same name and differing scope within your application."
In both cases activity isn't initialized yet (moreover you don't need to override activity constructor in the most cases).
First i will give you Dangerous Permission List in Android M and Later version
"If we do not hold all of the desired permissions, but isInPermission is true, we skip requesting the permissions, since we are in the"
Increment your database version number every time your schema changes.
It is not good practice to call your onCreate from the the OnUpgrade method.
You will likely have multiple checks for the version number as each version is published which allows you to incrementally upgrade.
"Replace the NestedScrollView in your xml(android.support.v4.widget.NestedScrollView) with the CustomNestedScrollView (which will take the form of com.something.somethingelse.CustomNestedScrollView, depending on where it is in your project)."
"For this, you will have to resort back to Android’s API."
"Ideally, you should straightaway call startActivity() on the button click &amp; execute the AsyncTask in onCreate()."
"You would display ""loading..."" in one of the data views there while the data is being downloaded."
No solution could work for the problem as Android version is 4.4.2.
PreferenceFragment uses the value stored in colorAccent of your app's theme to style widgets and titles by default.
"To apply it to your PreferenceFragment, call getActivity().setTheme(R.style.theme_name) in onCreate() of your PreferenceFragment."
"Regarding onCreate, which is the source of your doubts, you put it inside your View's subclass."
"The solution is to move the method, and its content in the outer class, the one that extends Activity"
"Usually, If Activity B is launched in onCreate of Activity A, the ""normal time"" of Activity B will be different from ""total time""."
"the ""total time"" will be printed only when it is different from ""normal time""."
"You should just do that once, in the onCreate of your activity or the onCreateView of your fragment."
However in your case you are reinitializing sharedPreferences everytime the event fires.
"In onCreate(), you would call startActivity() for the right activity based on API level, then call finish(), to pass control to the desired activity."
"The one identified by that explicit Intent, which would use Theme.NoDisplay (so it has no UI)."
Best practise is that if you open the Realm in onCreate you should close it again in onDestroy in all your activities as it means you reference count will reach 0 when all your activities have closed.
"As the regToWx method need to create something by this which is the context,but i think the context can not be used(in some ways) inside onCreate method."
In your case it will be null from the time class is created (so the constructor) until onCreate.
"It's just like if you tried to mark this field final - sometimes the field is null, so this is not legal."
"As OP commented on MossP's answer, this can now be achieved using the debug_http_host shared preference (see this issue)."
"Of course not forgetting to import android.content.SharedPreferences, android.os.Bundle, and android.preference.PreferenceManager."
i dont know if your code is correct in getting bluetooth device.
intialising and registering BroadcastReceiver inside a function is a bad idea.
here's the thing you need to do in your code
as about registering Reciver that has to be done in onCreate() like this
In the constructor it is way too early to access the app context.
More datails about the life cycle can be found in the documentation
Because this refers to the subsequent parent which is in this case Button.
that's fine Because in that case this refers to the activity.
onCreateView() allows you to inflate a layout for a fragment and get your views with findViewById().
The fragment's onCreate() gets always called directly before the onCreateView() method.
"It does not allow you to setup a fragment layout, so you always have to override onCreateView()."
"An activity does not need onCreateView(), since it has the setContentView() method, which allows you to setup a layout in the activity's onCreate()."
Usually I use a base Activity/Fragment when I need to do some work in some of life-cycle callbacks of all of my Activitys/Fragments.
"In child activities when you call setContentView at the beginning of onCreate (after calling super.onCreate), ButterKnife.bind would be called automatically."
"After spending many many hours with tries, searching and thankfully with some assistance from the creators of the support library."
Handle the recreations of activity / fragment add in onCreate so as to avoid losing your fragment when inside a preference screen.
Do not add the fragment by xml you will have crashes on orientation changes.
The host activity of the fragment should implement the  PreferenceFragmentCompat.OnPreferenceStartScreenCallback and recreate fragments of the same instance.
"if you annotate your views with @ViewById, then you cannot reference them in onCreate(), you need to make a method and annotate it with @AfterViews and when this method gets executed then your views are ready to be used)."
"Because of how Android Annotations operate, they embed themselves in the life cycle and doing so, you are now dependent of their lifecycle (e.g."
"Do not call methods that you are inheriting from Activity until after super.onCreate() has been called, unless specifically told otherwise."
"When such a change occurs, Android restarts the running Activity (onDestroy() is called, followed by onCreate())."
"  Some device configurations can change during runtime (such as screen orientation, keyboard availability, and language)."
The restart behavior is designed to help your application adapt to new configurations by automatically reloading your application with alternative resources that match the new device configuration.
"With that in mind, to prevent onCreate() from being called every time you change orientation, you would have to add android:configChanges=""orientation|screenSize"" to the AndroidManifest."
"However, if your application targets API level 12 or lower, then your activity always handles this configuration change itself (this configuration change does not restart your activity, even when running on an Android 3.2 or higher device)."
Move the code that was in onAttach method to onCreate one since it gets still executed.
"For unknown reason, this modification results in the fact that the method onAttach(Context) is not called anymore during the fragment lifecycle."
"With this modification, the app turns to run as before."
"You have not inflate errorText TextView like you have inflate email, password EditText."
Connect and disconnect the api client in onStart and onStop as suggested in Google Api documentation.
To get back the data to the activity I used a BroadcastReceiver created in onCreate
"At this point, your View has not measured its dimensions, so View#getDrawingCache() will return null because width and height of the view will be 0."
You can move your screenshot code away from onCreate() or you could use a ViewTreeObserver.OnGlobalLayoutListener to listen for when the view is about to be drawn.
Only after View#getWidth() returns a non-zero integer can you get your screenshot.
You can simply use Class&lt;T&gt;.getCanonicalName() and then instantiate the class by that name when reading it from the Bundle.
"In general, it's good practise to allow base classes to initialize first and destroy last - that way, any initial state from base classes that a derived class depends upon will have been sorted out first and, conversely, any derived class cleanup code can rely on the base class data still being valid."
Call your setupPicasso() method from onCreate in your own Application
"It does not work by default because , when you change the orientation onCreate will be called again and it redraws your view."
"When the Activity comes back to the foreground onStart() is called, but not onCreate() so the BroadcastReceiver isn't re-registered."
"The reason for this is that onStop() is called when the Activity goes into the background, but is not necessarily destroyed."
You will get a new onCreate and new onStartCommand (you go through the entire life cycle again).
If the location you stream from is set from outside your service you will need to store the location when you set it and set it again when you are re-created.
Anyway you can just always request permissions in onCreate() and then ignore calls to onRequestPermissionsResult() with zero-length permissions arrays.
"You can set a custom UncaughtExceptionHandler in your Application's onCreate(), but I would limit this to logging data and perhaps preparing to send that to you for debugging purposes, and then forward the call back to the default UncaughtExceptionHandler."
"The only thing you should be doing is using some kind of crash reporting library to report crashes back to you without the user having to do anything, so that you can fix your app and submit an update."
You could also subclass Application and create one there in onCreate().
You can't use context before it's initialized during activity lifecycle.
Because in Fragment lifecycle onCreate method called before onCreateView method.
"You should store the lat long in the onCreate() of the activity or some other place as per your other code, and then use the same in onOptionItemSelected()."
mMap.getCameraPosition().target returns the location that the camera is pointing at.
Btw you can combine the zoom and lat long in a single statement as follows.
The thing is that you start the thread in a wrong way.
"The thread is taking very little time, so if it is inside onCreate() method, It finishes before the UI even appears on the screen."
"Our thread does only one thing - text changing, thus it finishes very fast, before even onCreate() method returns."
"Call listView() method inside onCreate then try, it should work."
First onResume is only called when activity in the baground comes to the foreground.
Second in your function setUpMapIfNeeded() in the last if statement instead of putting setUpMap() you put setUpMapIfNeeded() change that and it should work.
"First of all, the Application's onCreate() is irrelevant in your use case because you can't have a thread running in the background when it was first initiated in a non service code."
After struggling with this for a few days I realized that the problem actually was that I passed the wrong FragmentManager to the ViewPager.
"However, if you look at your MainActivity's onCreate(), you can see that you never check the last level state before starting the intent."
"The app runs, the user clicks on button ""b1"" and it immediately starts Lev1Activity."
"To offer an alternative to Ben's answer and flesh out my earlier comment, one possibility is to create an ImageView in your xml that occupies the entire screen, with its visibility set to gone."
"On your button press, load the image into this ImageView, and on a back press set the visibility to gone again."
The onCreate method is run every time needed by the actvity lifecycle.
I'm using this way to add Fabric (Crashlytics) to my LibGDX projects.
"Now add android.permission.INTERNET permission in your manifest, also in onCreate method of AndroidLauncher add this line"
"As per documentation, views should maintain their state without using setRetainInstance(true)."
"Try to remove it from your onCreate, this should force the fragment to be recreated on screen rotation, hence all of it's views should be saved before rotation and restored after."
"It's called in the function named performLaunchActivity of class ActivityThread, before onCreate."
Not to mention contextHolder variable you put your holder object in shown code is of local scope and visible in onCreate() only.
"The behaviour of CLEAR_TOP is different, depending on whether or not the Activity is a singleTop activity or the flag SINGLE_TOP is also provided."
Creates a new instance of the target Activity and calls onCreate() on that instance.
Clears the Activity stack back to (and including) the target Activity (by finishing all activities in the stack that were on top of target activity and finishing the existing instance of the target activity).
java.lang.NoClassDefFoundError is propably thrown because you have reached the 65k limit http://developer.android.com/tools/building/multidex.html#about
You cannot access resources before onCreate() of the activity lifecycle.
You'll need to embed this data into the path that you append to the URI scheme.
"Or you can use a service like Branch that lets you bundle unlimited data in JSON format into a link, that is retrieved on link click and app open."
"Bit late to the party with this one, but I spent a while working on this and found a solution, which may be of use to anyone else trying to do the same thing."
The trick here is to force the menu to be invalidated in the activity's onCreate event (thereby causing the onPrepareMenuOptions to be called sooner than it would normally).
"Inside this method, we can locate the menu item and style as required."
What the warning is telling you is that actionBarColor shouldn't be a global variable (i.e.
"a field), because it's only used in one method (onCreate)."
The first error is due to the @Override annotation on top of your first onCreate method.
"onCreate is a method of your superclass, Activity, and is defined like your second onCreate method, it needs to be protected and take a Bundle object as argument, otherwise it doesn't override the superclass method."
"To fix this, simply delete your first onCreate method and move the code you need to the second one."
The second error is due to the fact that you haven no variable with the name XYB***********2P so the compiler doesn't know what to do with that.
"There isn't a setting in the manifest, and Huawei has enabled Tinder because it's a popular app."
There isn't a way to know if apps are protected.
"If we do that, we get the exception during onDestroy()"
Thus I ended by calling finish() in the onResume() of the activity.
"If I could clear that list, then I could call finish() in the onCreate() itself."
"Though I have found out the solution, I can't seem to find how to clear the list of fragment history that Android maintains when activity is recreated."
Take a look at the sample code inside journeyapp's repository here.
You have to resume and pause the barcode view inside onResume() and onPause() respectively.
In AwsStartAct onCreate() you're using the wrong id bHadoop for button Database.
"It's not in the layout, so findViewById() cannot find it and returns null."
"When using the Android Beacon Library to detect beacons in the background, you construct a RegionBootstrap class in a custom Application class as described in the Starting an App in the Background section of the samples."
You are welcome to execute code to call a service to get information about whether beacon scanning should be started and what identifiers should be used in the Region definition.
"You could construct a dummy region in the Application onCreate method for instantiating the RegionBootstrap, and then use method calls like above to configure different ones when you get a callback from your web service."
Note that it is also possible to use the above technique with the initial setup.
"Note that when stopping monitoring of a region, you need a reference to the region."
@InjectView is no more available and is replaced by @BindView.
Note that you will need to call ButterKnife.bind(this); from onCreate() method of the main activity to enable Butterknife annotations.
An example on this implementation could be something like :-
make a intent as class variable and set the value of this intent when  onActivityResult called like this.camaraData =data;
call only one way to handle this either in onCreate()or by using onRestoreInstanceState() function your problem will me solve as per your requirement or you can keep both but call of onActivityResult(...) function only from one place by checking whether its called or not by using boolean value as given in example
If the resulting data if of another nature than a String you could put a Parcelable Object as an extra to your activity.
"First, you'd have to define the parent Activity for the one you'd like to display back button in."
"In this answer i use map, but you have to use your mapFragment, but if you want to use it in other methods over onCreate, you have to declare outside of it."
"In your Main Activity class, you can just simply add this line of code navigationView.setItemIconTintList(null); to your onCreate method."
Facebook SDK 4.x now automatically stores the user logged in state.
"At onCreate() method, there isn't data filled, so it is always throwing NullPointerException or NumberFormatException - as said in comment by @ Roberto Tellez Ibarra"
You must retrieve values of EditText after it is filled.
You can't ensure this inside onCreate as you are trying to retieve values as soon as view is up and user doesn't get chance to enter those values in EditText.
"Your CrimeFragment, in its onCreate() method, gets its hosting activity (through getActivity()) and then attempts to get an UUID from the Intent used to start that Activity."
"If that activity does not comply, you'll see an exception being thrown in CrimeFragment's onCreate()."
its intent should have (in it) an extra defined by the name EXTRA_CRIME_ID.
Try having this fragment in a new activity created by yourself to see what happens.
"Basically, call this method in the onCreate, just before setContentView"
Initialise the Toolbar and call this method in onCreate of your Activity
That way you will make sure that it is always initialized.
"As N1to says, you need to add your controller in the AndroidManifest.xml, if you don't add it then the onCreate() is never called and when you call AppController.getInstance() the instance is null."
Parse.initialize() should only be called once for an entire application.
"Calling it in an Activity's onCreate function can cause it to be initialized more than once, as an Activity can be created more than once during an app's lifecycle."
"Upon completion of onHandleIntent(), if there are no other pending Intents to be processed the Service stops."
"According to the current documentation (Dec 2018), it shows that onAttach() is called right at the beginning before onCreate() and onCreateView()."
"The important part here is that the ""activity has been created"" i.e."
As you didn't assigned any refrence to mContext variable inside onCreate method.
You are referencing your views wrong inside of onCreate() in the fragment class.
"The way you have it written, you are trying to reference the views before you've given them a value, hence the NPE."
"You'll have a MainActivity entry point, that in onCreate() immediately reads that setting and redirects to the right Activity."
If it was extending Activity the onCreate will be called when reopening
After setting the action and category of my new activity i needed to add code to the activity.
First define the EditText variable as an instance variable in your class
Now you will be able to use the mEditText variable wherever you would like as shown above.
Setting the theme via setTheme(int resId) in the onCreate() method won't have any effect on the StatusBar since it is not part of the Activity itself afaik.
You can get the Floating Action Button in your fragments e.g in onCreate method of fragment by doing something that
"Within onCreate(), the Toolbar stuff is all standard, so we can skip that."
The code inside the if statement is what sets up the fade-in animation (wrapped in an if so it only fades in on first launch).
What that codes woud do is to set your ToolBar elevation to zero; removing preset shadows that were given as a default to ToolBars.
You have to move these codes after your setContentView in the onCreate method.
Don't forget to persist your title stack in onSaveInstanceState() in your MainActivity and restore it in onCreate().
"Override onActivityResult() in your MainActivity so that when PopupActivity returns, you set the title bar with the title at the top of stack."
"That might seem like a lot of work just for maintaining titles, but you will drive yourself crazy trying to do this with onResume."
"After looking for a solution for half a day without a result, I came up with an own implementation."
"It was important to put circularRevealActivity() into a OnGlobalLayoutListener, because the view needs to be drawn for the animation."
"A reference to a Serializable object is still an object reference, it's no different from passing a List object or a Foo object."
"You assumed that your Serializable object is serialized immediately by Bundle, where instead the Bundle simply holds a reference to your object."
"Of course, you should not rely on these references to stay intact."
"Looking at your code, you haven't actually created the table, you'll need to add createTableIfNotExist to the onCreate method of your OrmLiteSqliteOpenHelper class."
"Now the problem is, that in my cursor cursorCategory I get the data that is stored in the Category table of my database."
Possibly because the other helper populates the database in its onCreate() and the other doesn't.
  But it works here but not in the other case.
"You can programmatically create a BroadcastReceiver in your Service that listens for the ConnectivityManager.CONNECTIVITY_ACTION action, calling registerReceiver() when you want to start listening (say, in onCreate() or when you show the notification you eventually want to hide), then calling unregisterReceiver() when you want to stop listening (such as in onDestroy() or when you remove the notification)."
You can then retrieve the connectivity by using code such as
"Create the adapter and the ""non-view"" related objects in onCreate."
"  Report that this fragment would like to participate in populating the options menu by receiving a call to onCreateOptionsMenu(Menu, MenuInflater) and related methods."
"Do not use an Activity in an initializer, as the activity is not ready yet."
Try moving your broadcast receiver registration to onCreate and onDestroy instead.
"Taking a look at this question regarding onResume and onActivityResult, onActivityResult gets called before onResume, so by the time your fragment registers as a receiver it's too late."
It looks like the main issue is that you're running with an older version of Google Play Services.
(after FATAL EXCEPTION:) tells us you are trying to parse an int but the value you are trying to parse is an empty String.
"From the line above, we can see that the error happens in MainActivity in the method xmlToVar at line 72 which should be"
Save the name of the current Fragment class in the Activity's onSaveInstanceState().
In your application class call the set the following in onCreate.
here is my Android mainactivity class that should be injected but its not
"You can do this in a couple of ways, I will describe two."
"In this case, you create an instance of VehicleComponent, implemented by Dagger, and fetch the Vehicle instance from it."
"Said that, your intent of keeping the activities 150 lines long is too restrictive."
"Now, I totally hate inner classes and am trying to avoid them at all costs."
"Probably you've already found an answer to this but in case you haven't, here's what I did to fix it after a few hours of scratching my head."
"Now there are quite a few ways of going about doing this but this is what I ended up with inside my ""detail"" activity, i.e."
You need to be careful since the Activity may not yet be attached to your ViewPager fragment so it's easier to just pass in the transition name from the activity to the fragment if you're loading it from a resource
showVideoFragment() actually add fragment to Activity instead of just show it.
"You have to call Cursor c= getReadableDatabase().rawQuery(""SELECT * FROM friendinfotable"",null);"
When implementing a Fragment you don't inflate your views in onCreate() (like you normally do in an Activity.)
"For me, the Smart Lock for Passwords on Android sample project worked fine."
"For example, if you added it in onCreate remove it in onDestroy."
You might want to check out Collections.shuffle() instead of implementing it (don't reinvent the wheel etc).
Follow this --> Implement Floating Action Button – Part 2
On 'Animate to Hide' put that on the onCreateView or onCreate method so that on your FAB is hidden when you create this fragment and you could then add a handler and runnable that will trigger 'Animate back to Show' after a second or two to show your animation
"but we dont want it to animate just to hide it so, 'Animate to Hide' will just be something like this"
All the answers seem correct so I'll go ahead and give a complete answer here.
"Note the onCreate() method, where we are starting a foreground service differently for Build versions greater than Android Oreo."
"You've left that previously declared imageView untouched, and instead made a brand new one that's absolutely useless and dissapears after the onCreate() finishes."
Because the way you're doing it now means that you've declared a new imageView instead of using the one already declared previously.
"When you call imageView.setImageBitmap(bitmap);, you'll get an NPE because it tries to use the imageView declared in your class."
You need a Context to get resources (as you can see in the Docs getResources() is a method of Context).
You can declare the variable before onCreate() but you can't initialize it until after onCreate() has been called.
Declaring it as a member variable this way but initializing it in onCreate() will allow you to use it throughout the class and keep it from crashing.
don't make the call to super() on the saveInstanceState method.
in fragment you have to use layoutView to get views instances.
you can declare layoutView as a class variable instead of local variable in onCreateView to make it accessible in whole fragment.
"above suggestion are basics, now post question for specific requirement/issue, to get more helpful answer."
Attempting to find any views before the window is initialized will lead to NPE.
  lifecycle callback method) always run in the UI thread of the process.
"There are only a few classes that do start asynchronously, like the IntentService for example."
You can set a listener on the onCreate() method on your activity
"Third, you put the locMan.requestLocationUpdates(LocationManager.NETWORK_PROVIDER, 30000, 100, this); inside your updatePlaces() method, you should remove it, because it will keep looping the updatePlaces() method, bad for your app and API quota limit."
1) In the activity's onCreate() method after setContentView() you need to set a new OnClickListener for each button.
"common in 1,2) You need to assign an id to each of your buttons in the layout XML file"
"2) As you see in the first approach, we need to make a new Object from the OnClickListener for each button."
"As FunkTheMonk have stated, the crash is due to the fact that your customized onCreate() code in your Activity (right after super.onCreate()) is executed after your customized onCreate() code in your Fragment (right after super.onCreate())"
Otherwise the aforementioned condition will happen when your memory is low and the activity is recycled.
onCreate() of your fragment can be called before onCreate() method of your activity has been finished.
You can use any of it - it executes after onCreate method of activity.
Put this part into your Fragment's onCreate() (NOT in the activities onCreate) and double check if the key pref_updates is used in your xml.
It seems that the best implementation would be to just use an ArrayList&lt;LatLng&gt; to store each point given in onLocationChanged().
You can use this code to turn the screen on.
"There is an one more alternative for doing this, for that you need to launch an activity, In the activity onCreate() you need to add the flags to the window."
After checking the documentation I found that they are asking to initialize FacebookSdk in Application class onCreate() Method.
"Do not use getSupportActionBar().setTitle(title); to set the title, if you have a custom Toolbar layout."
"In onCreate, if savedInstanceState is not null, restore all your data and set all the fields."
Override the method onSaveInstanceState and persist all your data in the bundle
"When your activity restarts due to a configuration change, onSaveInstanceState gets called and savedInstanceState will be not-null when onCreate is called."
Not all of them trigger an activity restart but some do.
"I'm posting an answer here because, while the other solutions were helpful, none of them answered the question exactly."
"Inside of the NavigationDrawerActivity class, in its onCreate() method, I execute the following (thanks @Tinadm for this part of the answer): getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN);"
"The transition/animation makes the theme change seamless when you restart the activity, and this can be done by adding the items ""android:windowanimationStyle"" to your themes, and then referencing a style where you specifiy how the Activity should animate when it enters and exits."
"Yeah, you should use these lifecycle methods just like with plain Android activities."
"If I understood you correctly, the issue is that the phone's locale is restored when you switch the screen orientation, despite you have android:configChanges=""orientation|screenSize|keyboardHidden"", in your AndroidManifest.xml."
"When onCreate is called again, and you know is called due to the orientation change because the bundle is not null, read the Locale stored and restart, and update the configuration again."
"That is, if you have any WebViews in your layout, make sure you call this method before calling setContentView() in your onCreate()."
For this case you need to implement a custom test runner which will subclass AndroidJUnitRunner and will override the callApplicationOnCreate() with your custom setup.
The system will call onSaveInstanceState when it is about to kill your app because of memory problems.
When the Activity is recreated you can restore it in onRestoreInstanceState or onCreateor any of the following in the fragment life cycle.
You have made an assumption that the Fragment instance remains in existence as long as the app is alive.
You can use AppCompatDelegate with matching activity lifecycle callbacks for anything related to action bar.
"  callback to it at every call it exposes (for instance onCreate()), but"
  it’s really simple and can be extracted into a base class.
In Fragments you need to null check getActivity() since the Fragment can outlive the Activity.
Take a look the following tutorial for more details: http://codetheory.in/android-image-slideshow-using-viewpager-pageradapter/
"onCreate(), onStart(), onResume(), etc) are called by the android system directly, don't ever explicitly call them yourself."
Consider the activity lifecycle here to see how the system calls each method.
You've just inadvertently overloaded the default onStart() method provided by android.
Either you dump all that code into onCreate() or name the method something different so you don't confuse yourself.
The article isn't very clear as it misses out the setup steps.
"in @Before), it replaces the Activity's reference to a GitHub API implementation with a mock one."
"2) During onCreate(), the activity makes a call to the now-replaced GitHub API, passing in its Callback object."
"Those first two steps explain why the Mockito.verify(mockApi).repositories(Mockito.anyString(), cb.capture()); step at the beginning of each test works."
"Don't forget to associate your mapview with the fragment lifecycle calling the events onCreate, onLowMemory, onPause, onResume and onDestroy (hope not missing any of them), and call to MapsInitializer.initialize(getContext()); as well"
"Make sure the Activity root layout is something with Z ordering, like RelativeLayout or FrameLayout, and position the toolbar &lt;include&gt; at the top of the Y axis (alignParentTop for RelativeLayout or layout_gravity=""top"" for FrameLayout), and put the Toolbar &lt;include&gt; after whatever layout you will be putting your Fragments inside, so that it will overlay them."
"You should download the image inside onCreate, save it in a static variable, call mClusterManager.cluster(); after saving the image, and finally inside onBeforeClusterItemRendered wrtie marker.icon(BitmapDescriptorFactory.fromBitmap(YourActivity.b));"
"When downloading the image inside onBeforeClusterItemRendered you are actually downloading the image every time the Cluster Manager tries to load a marker, so if you have, for example, 100 markers you will download the image 100 times."
"As such, to better organize the desired session management functionality, the following structure should be used."
Functionality related to tracking user sessions is then sequestered to the SessionTracker class.
"It is important not to block that thread, and so if you are running on that thread (e.g., onCreate() of activities and fragments, onClick() of a widget, getView() in a ListAdapter), you need to return very quickly, ideally in well under a millisecond."
"However, it is the thread that is responsible for dispatching key and touch events and otherwise applying UI updates."
"Otherwise, you have ""jank"", defined in Android as being a frozen UI, particularly while the UI should be animating (e.g., scrolling a ListView)."
onCreate() version you are currently using is added in Android 21.
"In my case, I used: package com.mycompany.myapp.view; in both of these files."
"You can't call findViewById, before the activity is created, and swi.setOnCheckedChangeListener(..); is not a valid statement"
"You should never ever call the onCreate method yourself, the SQLiteOpenHelper class will do this for you automatically."
"As a side not, to solve my problems I had to notice (with a great deal of debugging) that after the method onActivityResult() has finished, the MainActivity's onCreate() is not called a second time and the execution of the class ends with the end of onActivityResult()."
For this reason I couldn't rely only on SharedPreferences to update the user's information.
"In fact even though the SharedPreferences do their job well by making all the needed information available everywhere in the project, when the onCreate method isn't called a second time, there would be no way of update the RecyclerView.Adapter with the new information and no extra code, making the SharedPreferences to become pointless."
"For these reasons, updating MainActivity's account fields was impossible to perform without the mAdapter.notifyItemChanged(0), which did the job on the fly."
"Having said that, any subsequent call to onCreate() method in MainActivity would load the account information from SharedPreferences() until the user wouldn't logout somewhere else."
Use addOnBackStackChangedListener which adds a new listener for changes to the fragment back stack.
"Now As soon as Fragment-B is destroyed, onBackStackChanged is called and I was able to set the focus."
"You can check, if user logged, by calling the method Loginmanger.logInWithReadPermissions, to manually start login process, without button."
"If user are logged, it immediately call onSuccess callback method, where you can call your shareDialog."
Alright so from your post I'm guessing it's only inflating one of your layouts into the CardScrollView try the following.
In your activity class create and fill a list with the desired layouts and pass them to your adapter as follows.
"Taking the algorithm from this answer from the question posted by @shieldstroy, that uses the Great Circle Distance, I got this example working."
The main issue: you never call mLocationClient.connect() so the connection process never starts.
"Similarly, you should removeLocationUpdates() in onDestroy() and disconnect your mLocationClient."
"in onCreate() of your root Activity, set this variable to true."
"Anytime you're going to use Facebook components, you need to ensure that the SDK is initialized."
It doesn't seem to make sense to me to tie the startup / shutdown of this background task to any one single activity since it may not be the same one activity that starts up when the application becomes active.
"In terms of startup, you could use onCreate() on that same Application singleton."
"If, when one of those arrives, you determine that your streaming thread is still outstanding, shut it down."
"The problem is that this will be called on any process creation, which may include scenarios in which you do not have UI (e.g., you are responding to some system broadcast, like ACTION_BOOT_COMPLETED), or possibly your process is going to parts of your UI that do not depend on the streaming."
"Otherwise, kick off the streaming in onCreate() of whatever activities need it."
"While normally we manage long-running threads with a Service, that is for cases where we explicitly want the thread to continue after our UI is in the background."
"In order to not break the design consistency amongst different UI components in android,the onCreate() method will have similar functionality across all of them."
When linking Containers to Contents  like Window to Activity and Activity to Fragment a preliminary check needs to be done to determine the state of container.
"Why would you want to use a method like onCreate() which is has the same purpose in an activity ,service."
The onCreate() is meant to handle issues with respect to that particular context creation.It does not make sense if onCreate() is used to check the state of its container.
The second reason that I can come determine is that a fragment is designed to be activity independent.The onAttach() provides an interface to determine the state/type/(other detail that matters to the fragment) of the containing activity with reference to the fragment before you initialize a fragment.
"  activity has received its onCreate() callback, a fragment in the"
  activity receives no more than the onActivityCreated() callback.
The onCreate by definition is responsible  to create a fragment.
A fragment (by design) could(and should) be used across multiple activities.
All these situations would require a check before the fragment is initialized from the android perspective(onCreate()) and the view inflated(onCreateView()).
- To be used only on tables and mobile phones.
If it had been called after onCreate() then there would be no context for your fragment (getActivity() would return null) and you would not be able to do anything in onCreate() method without that context anyway.
  onCreate(Bundle) will not be called since the fragment is not being re-created.
"  onDestroy() will not be called (but onDetach() still will be, because the fragment is being detached from its current activity)."
onAttach() called after Activity super.onCreate() call - Activity is already initialised.
Fragment is added dynamically using FragmentManager or inflated from XML via setContentView().
"Fragment onCreate() not called, but onAttach() still called - you need to know, that hosting Activity has changed."
"Ok if I got your question right, you want a layout with a background and a scrollview."
Both Activity and Fragment Shared transitions can be difficult to debug.
"In debugging shared transition from A to B, I usually find VERY useful to Override onMapSharedElements methods, so you can easily figure out which shared elements in A are being associated to elements in B."
"In this way, it will be easier to figure out which elements are not being mapped (maybe they're simply not created yet) and to solve Shared transition issues (ie: glitches, artifacts)"
"Looks like you already use a class variable to toggle the light, so it looks like all you have to do is move the whole thing from onCreate() to onResume()."
"However, the whole thing may not behave correctly since you don't have a UI."
"In the onCreate method of the BaseActivity, we have to check if the"
"When you press the Button in E,  you add the names of B and D to the activitiesToKill  object."
Make sure to remove the name of the activity if it is killed through the broadcast.
More advanced checks can be accomplished in case you have groups of activities that needs to be terminated through different conditions (not only a button click) so you can have a HashMap of a HashMap to divide them in categories.
"If login succeeds, the LoginResult parameter has the new AccessToken, and the most recently granted or declined permissions."
"You don't need a registerCallback for login to succeed, you can choose to follow current access token changes with the AccessTokenTracker class described below."
Every activity and fragment that you integrate with the FacebookSDK Login or Share should forward onActivityResult to the callbackManager.
"You should always do the work in IntentService's onHandleIntent(), not in onCreate()."
The reason because your IntentService stops immediately is you haven't supplied any code to onHandleIntent().
"For this reason, it would be better to stick with a single launcher activity."
"When the user returns to your app (or restarts your app), Android realizes that it had killed your app previously, so it creates a new OS process to host your app, then it instantiates the Application instance for your app, then it instantiates the topmost Activity in the task stack (ie: the Activity that was on screen at the time your app went into the background), then it calls onCreate() on that Activity so that the Activity can restore itself."
"In this way, the Activity has a chance to restore itself."
"in onCreate() of all activities, check if the ""app initialization"" has been performed by using a public static variable or singleton."
"If the initialization has not been done, you know that your app's process was killed and recreated and you need to either redirect the user to your root Activity (ie: start the app all over again) or do the initialization immediately in the onCreate() of the Activity."
Save the data you need in onSaveInstanceState() and restore it in onCreate() and/or onRestoreInstanceState() or both.
You assign that OnClickListener to that button using btn.setOnClickListener(myOnClickListener); in your fragments/activities onCreate-method.
You create an instance of OnClickListener* like it's done in that example and override the onClick-method.
"When the user clicks the button, the onClick function of the assigned OnClickListener is called."
"You're using the activity as a Context too early, at member variable initialization."
You need to wait until onCreate() or later in the activity lifecycle.
The crash seems to be related to the applicationId we are setting in the AndoridMenifest.xml file.
As i figured out that when facebook sdk is tying to create the LoginFramment then ApplicationId is comming as null.Here is onCreate method of com.facebook.login.LoginFragment class
As pointed out by the varoius post the applicationId is coming null because the string resource app_id is not being parsed correctly by android.
Call startService(intent) in the onCreate() method of the first Activity.
so I recommend  to use this script to get the status bar height
"After testing and searching a lot, I implemented by my own, combining a ListView with inner HorizontalScrollViews."
"that will scroll to the received position, if was not itself that fired the scroll event."
"(Please ignore some weird coloring, it's for better viewing what's happening)."
"Move the initialization into your onCreate() method, after your setContentView() call."
"Works for Android KitKat and above (For those who want to transparent the status bar and don't manipulate the NavigationBar, because all of these answers will transparent the NavigationBar too!)"
Main problem is You are initializing your spinner above your view.
on top and after that you should initialize other components.
"Meaning, this will only help you if the user is already logged in."
You don't own the database that was passed as an argument and you should not be closing it.
"While there is an onRestoreInstanceState() method you could override, I typically restore during onCreate()."
Usually more convenient to when other things are getting instantiated.
You'll want to move all that initializing data to onCreate() instead.
If it's not and instead you are seeing it reload the initial data...then you are probably reloading the initial data in or after onStart().
Start the MainActivity when the ProtocolCatcher Activity gets started (MISSING)
"Considering the fact that you are ""injecting"" the ProtocolCatcher Activity manually, if you have problem to refer MainActivity from the ProtocolCatcher onCreate() you can lookup the relative Class using reflection."
"Can you make sure that you are calling these statements from the ""main"" thread (for example inside the onCreate() method)."
"As soon as I call the same statements from a ""delayed"" method."
"That's because you're first setting the View using setContentView, which basically just displays the Layout you have inflated inside your current Activity."
"Place the following code inside the MainActivity.onCreate, delete the Intent Extra stuff."
Note that there is no need to call GooglePlayServicesUtil.isGooglePlayServicesAvailable() if you are using GoogleApiClient as connect() includes that check as well.
"For adding a ToolBar that supports Material Design, the official documentation directions are probably the best to follow."
Note: You will have to import the following in the activity.
Ok so I managed to solve this after some trial and error.
The onCreate() method in a Fragment is called after the Activity's onAttachFragment() but before that Fragment's onCreateView().
"In this method, you can assign variables, get Intent extras, and anything else that doesn't involve the View hierarchy (i.e."
"After the onCreate() is called (in the Fragment), the Fragment's onCreateView() is called."
You can assign your View variables and do any graphical initialisations.
"As the name states, this is called after the Activity's onCreate() has completed."
"It is called after onCreateView(), and is mainly used for final initialisations (for example, modifying UI elements)."
"The onCreate() is called first, for doing any non-graphical initialisations."
... they are all called in the Fragment but are called at different times.
"Next, you can assign and declare any View variables you want to use in onCreateView()."
"Afterwards, use onActivityCreated() to do any final initialisations you want to do once everything has completed."
"onDestroy() is also called in other scenarios, such as finish(), the default behavior of the BACK button, the default behavior on a configuration change, etc."
"No, because the whole process is terminated ""if the app moves from onStop() to onCreate()""."
(I'm not sure if this is a simple layout question or an issue with overlapping SurfaceView surfaces; I'm going to treat it as the second.)
The call must be made before the surface is created (e.g.
"For an example, see the ""multi-surface test"" activity in Grafika."
"The savedInstanceState that you save in onSavedInstanceState() is    returned in onCreate() when the Activity is recreated, allowing you to reuse the data that you saved previously."
"By declaring android:configChanges=""orientation|screenSize"" you instruct Activity Manager to not restart your activity and let you handle configuration change via onConfigurationChanged()."
"Which means that onCreate() will be skipped on configuration changed, and you cannot swap your layout (since onCreate() is where you recreate the view)."
"In your case, you want to change layout, so there is no choice but to refresh your activity, which means to remove android:configChanges=""orientation|screenSize""."
The only method I can see that you are forwarding now is onCreate.
"However, a more convenient solution would be to use MapFragment or SupportMapFragment."
The system calls this method as the first indication that the user is leaving your activity (though it does not always mean the activity is being destroyed).
onCreate() is to onDestroy() &amp;&amp; onStart() is to onStop() &amp;&amp; onResume() is to onPause() .. onStart() is called when onCreate() finishes its work.
if not its not called.. onResume() indicates the ui is about to be shown to the user -(An Activity's content is the screen the user sees).
"if you call finish() in onCreate(), onPause() will be skipped because onResume() was never called same goes to onStart() .. so in some cases you can say its not; but that will be false, because what's an Activity that is not a screen or serve as a container for screens-(Fragment)."
"From how Activities work in general, onPause() will always guarantee is calling.."
"Run, and observe that your log will only contain ""onDestroy""."
"Typically, you do this in the onCreate method of your Application."
One good resource that may help you is the example apps in the Dagger 2 repo.
The Surface associated with a SurfaceView or TextureView will generally be destroyed when the Activity stops.
"There's a bit of a trick to it -- the setSurfaceTexture() needs to happen in onCreate(), not onSurfaceTextureAvailable() -- but it's reasonably straightforward."
"The example uses MediaCodec output for video playback, but it'll work equally well with anything that takes a Surface for output -- just create a Surface from the SurfaceTexture."
"You have initialized your SharedPreferences prefs as null, hence the NPE."
"For whatever reason, Parse has two tutorials; one is complete and the other isn't."
For full width dialog you can create custom style for dialog.
"By default, ViewPager recreates the fragments when you swipe the page."
"What is happening is that Facebook is launching your ""deep linked Activity"" with  Intent.FLAG_ACTIVITY_NEW_TASK (you should be able to verify this by checking the content of the Intent in your Activity in onCreate() or onNewIntent()."
"to the &lt;activity&gt; tag for your ""deep-linked Activity"" in the manifest."
These are the ones that you need to request in order to draw behind the status bar.
Alternatively you can also simply set your apps theme background and that will also pop up behind your status bar.
It is being filled in onSaveInstanceState(Bundle outState) and later passed to the new DialogFragment in onCreate() and onCreateView().
The savedInstanceState is only used when a configuration change occurred.
The first time a Fragment or Activity gets created it is null.
"For anyone who's still having this problem, do the following."
It looks like you are trying to put a Spinner in your menu XML.
"In your Activity's onCreate() you will need to call setNavigationMode(NAVIGATION_MODE_LIST), then actionBar.setListNavigationCallbacks(mSpinnerAdapter, mNavigationCallback), passing in a SpinnerAdapter and an ActionBar.OnNavigationListener."
At the onCreate or the appropriate callback you check if the dataset that feeds your RecyclerView is empty.
"If the dataset is empty, the RecyclerView is empty too."
"It will fail because of ""Cannot attach database within transaction""."
"read the function of SQLiteOpenHelper.java, I find out that onCreate() and onUpgrade() are called together during transaction."
the DB data is stored under /data/data/&lt;your.app.package.name&gt;/database/ (or something similar to that).
"If there's no file, it executes the onCreate (which creates the  DB file)."
"That means, the SQLiteOpenHelper class checks if a valid DB file exist on that location in disk."
Try to go File -- invalidate Caches and restart your Android studio.
"The main thread runs a Looper, which is an event-dispatcher (probably what you are referring to as ""main loop"")."
"Be aware that the Looper on the main thread also dispatches all of the lifecycle events (like onCreate(), onResume(), etc.)"
Activity#onCreate() is a lifecycle method and should never be called directly by your own code.
"Ideally, the setup code that an Activity requires to build and initialize itself should be run only once in its lifetime."
An Application is always started before any of its Activities/Services/Receivers.
  ContentProvider is called before onCreate() of the Application.
findViewById returns null here because you haven't yet called setContentView.
"In onCreate you can do ""CREATE TABLE IF NOT EXISTS"""
"After a week of research and try and error, I finally found a working solution."
"When overriding methods from a super class, you should always (most of the times) call the method from that class using super.method(), to allow normal processing."
You are trying to findViewById before the activity's context is ready.
I'm trying to prevent to execute code from SugarApp in onCreate and onTerminate (https://github.com/satyan/sugar/blob/master/library/src/com/orm/SugarApp.java).
The class named Test will be loaded and used by Robolectric and you can override some things that are not relevant for testing.
"If this is a problem for you, you can simply add a check and exit it immediately."
You already created a class member settings so you probably just missed this.
"The easiest way to get the same effect is to manually set these flags, which effectively disables the insets imposed by the Android layout system and leaves you to fend for yourself."
What I ended up doing to resolve this was use Calligraphy to set global fonts.
Simply just add this code to the onCreate() of my custom Application class.
"You're creating the GameActivity by calling the constructor directly, rather than it being constructed by the Android system itself."
"With no layout, there's nothing to find the view in."
"Second, do not call onCreate() directly on spied activity, you should call ActivityController's create(), in your case, call controller.create() instead of spy.onCreate(null);"
See my answer for spying a activity with robolectric in another post
Initializing pref  in onCreate method then no need to initialize again as currently you are doing in setOnCheckedChangeListener
"According to your logs, the outputs are FIRST displayed from the onCreateOptionsMenu() method and only the last one is from the onCreateView()."
That would mean that onCreateOptionsMenu() is called before onCreateView which would explain why everything is null.
"Try moving setHasOptionsMenu(true) somewhere else, maybe in the constructor That should make sure that onCreateOptionsMenu() is called after onCreate and onCreateView."
I'm assuming you are storing user's selected theme in App Preferences.
Because getResources().getIdentifier executing when onCreate method called but you are setting value in itemsa on onItemSelected of Spinner.
apparently you are using the countDownTimer inside your onCreate as an inner class so that will trigger the timer when startTimer == true and it would create the object no matter what!
You cannot do this to communicate between and Activity and a Service
"Your null pointer is because when you say new MainActivity() the activity you create is not attached to the lifecycle and so onCreate and other methods are not called therefore, no onCreate means no setContentView meaning all views found with findViewById are null"
The above code needs to be present also in onResume() method because each time orientation is changed onDestroy() is called and then onCreate() is called so onResume() needs to have this piece of code as well as onCreate().
The problem is that you mash together too many different things and that you don't respect the lifecycle of each class.
Move the code from onCreateDialog() in MapDialogFragmentv2 in the correct lifecycle methods in MyDialog.
Or even better move them to their own files all together.
"Add setStyle(DialogFragment.STYLE_NO_FRAME, android.R.style.Theme_Holo); to the onCreate() method of your MapDialogFragmentv2 after the super.onCreate() call."
Remove your constructor and use the onCreate() as constructor's are not typical usage when doing android activities.
"The orientation changes the layout of your Activity, so it's going through onCreate() once again (actually to let you adapt your UI to the new configuration -- portrait ain't landscape at all UI/UX wise)."
Try to never use android:configChanges (from the Android Dev Guide); this only avoids the problem and is a bad habit.
"Context, Configuration) and its onCreate() and other lifecycle methods are called."
"In other words, if you call finish() while creating the Activity in onCreate(), the system will invoke onDestroy() directly."
Move you Parse initialization into your App class (extended from Application)
"When you app receives push notification, then parse will not be initialized, because you initialize it at activity onCreate method, which won't be called."
See the Activities document for information about saving and restoring state.
in onCreate you can get the height of your screen and divide by 6.
"Now in your getView you get the reference of the top layout for each item, suppost you have named it's id to root and i.e it's a LinearLayout."
Try to initialized GPSTracker Object into onCreateView() or onCreate() like
"If I got you well, you want a white space between your password EditText and your Buttons."
The following code in the onCreate function will differentiate whether the app is started with voice or by a user tap.
The difference is the cat or category parameter which includes android.intent.category.LAUNCHER as a value.
In the onCreate method of your Activity or in the onViewCreated method of your fragment.
Please consider the fact that finish() does not cause the onCreate() method to stop.
"path_to_unzipped_files must not contain any spaces, or you will get error!"
If initialization is successful you will see true in Toast message else you will see false.
You're calling findViewById() too early and get NPE here because the activity won't have a Window before onCreate().
The Slider API relies on the View you used when initializing it to be VISIBLE so that it can properly recycle sliders that were started from Views that got hidden.
At that point the CardScrolLView you're using should have been attached to a Window and be rendered VISIBLE.
You have syntax errors in your CREATE TABLE you are ignoring.
You need to actually pass the SQL and not the table name to execSQL().
The callback needs to throw on error and not ignore problems.
"From what I can tell (and correct me if I'm wrong), what you are trying to achieve is basically something like this: Assume you have a MainActivity, a DetailsActivity, and an arbitrary set of images."
"By default, the activity transition framework will use the shared element that was used during the enter transition... but the view pager's page has changed so obviously we want to somehow override this behavior."
"For a more complete solution, I have created a sample project on GitHub that will achieve this effect (there is too much code to post in a single StackOverflow answer)."
"In ""HomeDetailFragment"", I can see the ""UP home icon"" but cannot get the click event of home icon onOptionsItemSelected not being called, so cant navigate back to HomeFragment"
The reason your code isn't getting called is because it is in the onCreate of your Fragment.
"  When pressing the Phone Back Button, and again navigating to ""Home Detail"" it is not showing ""UP home icon"""
Move it to the onCreateOptionsMenu instead to have it update.
"Your Service will need to call startForegrond() upon itself (e.g., in the service's onCreate())."
The Callback&lt;TwitterSession&gt; object needs to be set BEFORE the user clicks on the TwitterLoginButton.
"The mistake was that I had put this code in the Twitter button click listener, which is wrong naturally."
"findViewById can be used after onAttach is called, not before, because the context object you are indirecting using has not been yet initialized."
In the fragment where you want to hide the Item
Move register to onCreate and unregister to onDestroy of your MainActivity.
"If onCreate() returns normally, the framework thinks the database was set up successfully."
"If there's a problem, the framework should be thrown an exception."
onCreate() is only called once when the database is first set up.
Uninstall your app or clear its data to get rid of the old empty database file and to get onCreate() rerun.
"In your MainActivity, call the Injector in the onCreate() method."
you can save that option in SharedPreference and in your MainActivity's onCreate method change for saved value and then you can finish() your MainActivity and start SecondActivity
1) You should use onCreate method instead of onViewCreated to instantiate LfPagerAdapter;
"If I'm right you have to create a certificate, sign it and include it in your app."
"Extend your Application, and call the 'nuke' function in your onCreate"
"Probably this is more a workaround that proper support for test module overriding, but it allows to override production modules with test one."
We've to set the test component in App class before the MainActivity is created - because StringHolder is injected in the onCreate callback.
"In our tests we want to provide StringHolder with ""Test string""."
Fragments on backstack can always retain instance if you save it.
"Now to restore from the saved state you would have noticed that the onCreate, onCreateView for Activity, Fragment, respectively, have a Bundle savedInstanceState parameter being passed in."
to your onCreate/onCreateView method and you should be good to go.
"Ok, I figured it out: When I swipe my application from recent apps, both processes (main and service) closed, then serivce restarted."
"When I do that, new process with service is created."
All following startService() commands come into onStartCommand() method of the service.
Just put a break point into your service onCreate() and onStartCommand() and see what happens there.
"What I think is happening is that when you leave the Activity A, onStop() is being called on activity A since its completely hidden and B is on top of it."
Usually now when you resume activity A after pressing back onStart() is called and then onResume().
Calling recreate() essentially causes the Activity to go through a configuration change.
The FragmentManager will still hold a reference to the newly created fragment after the configuration change occurs.
"Although calling closeDrawer() from onCreate() will make the drawer start out closed without any animation, the same is not true from onResume()."
(You can skip past this explanation if you just want to see the code.)
Calling closeDrawer() from onResume() will close the drawer with an animation that is momentarily visible to the user.
Point A: The service code is missing a key component
"In the code above, the service has an onCreate and onDestroy, which will be triggered when the service is created and destroyed."
"However, if a service is triggered and it is already running, then it will not go through onCreate."
"It will, however, go through onstartCommand (onStart pre android 2.0)."
"As mentioned in Firebase API docs, the Firebase should be initialized before any Firebase reference is created or used."
Your xml shows that you have two android namespaces which actually should give you an error because in android you are allowed to use the namespace only once.
"To understand your issue, you need to understand how variable scopes work in Java"
"By using the same name for both class and local variables, the variable inside someMethod() is ""hidding"" the global class variable."
"However, inside your onNewItemAdded method, the todoItems refers to the class global ArrayList which was never initialized (and is thus null) and that is why you get a NullPointerException."
"since setContentView sets the content for the UI, I removed it from the MainActivity.onCreate() but I still get a white screen on app launch"
A small amount of refactoring is required because all variables and methods called from this method have to be static.
in your onCreate you never set the content before you try to access the toolbar view
you need to set the content first for your activity before you can access it
"You can, however, easily get around this by excluding the navigation/status bar backgrounds from the window's default exit/enter Fade transition."
"Adding the status bar and navigation bar backgrounds as shared elements will force them to be drawn on top of the window's default exit/enter fade transition, meaning that they will not fade during the transition."
As far as I understand this is caused by activity transition overlap.
There is just one important point: don't use onCreate() in the activity because it will lead to errors.
"From that point on, we can stick to the old solutions regarding preference screens and headers, without any deviation from the existing documentation."
"You can use their onCreateView() the same way, inflating your own layout instead of the system one, adding the toolbar the same way as in the activity."
"The only real difference is, and that's what makes it work with nested screens is that you can use the same approach with the fragments."
Next step is to add (Override) onCreate method in your settings activity
"Make sure you add a list view with android:id=""@android:id/list"", otherwise it will throw NullPointerException"
Don't try to set the sharedElementsTransition in the onCreateView of your Fragment.
You have to define them when creating an instance of your Fragment or in onCreate.
Take note of the official documentation on the possible animations for enter/exit transitions &amp; sharedElementTransition.
"According to this document, add the following code to onCreate"
"Although probably a little late to answer this question now, I realised that I wrote an answer on a similar question which covers both using the Design Support Library and prior to Google I/O."
Create and initialise a Realm object inside onCreate and close it inside onDestroy pretty much like closing an SQLiteOpenHelper instance.
Construct the RecyclerView in code and supply the data it needs.
At the simplest your onCreate inside the Activity will look like this.
"Notice that in the first step, I query Realm to give me all objects from the Data class sorted by their variable name called data in an asynchronous manner."
your problem causes by your EditText it has focus so you must remove focus from it;
if the above dose not work then for all of your EditText call setFocusable(false);
The easiest way is to the to add the ProgressBar directly in the XML-Layout files.
Now you can access the Toolbar and the ProgressBar in the Activitiy onCreate method
Using a RelativeLayout as root and use android:layout_below to keep the ProgressBar and the main content below the toolbar.
more methods of Support Toolbar (Appcompat v7) in onCreate works only with
"Problem only with onCreate event, you still can use mToolbar.setTitle() later instead of annoying getSupportActionBar().setTitle(), for example if you add this in onCreate it will work (because it will be executed later, after onCreate)"
"as i wrote on comment, checking visible rect at onCreate won't work."
Try this code at end of onCreate (instead of call checkAndUpdate() directly).
View layout does not finish though if you added view at onCreate.
"yes, this time user cannot see the actual activity and view's actual size are not set."
"The recommended method to create a new SQLite database is to create a subclass of SQLiteOpenHelper and override the onCreate() method, in which you can execute a SQLite command to create tables in the database."
"Open the database once, in onCreate(), not on every query() call."
"Though, in all honesty, if you are not implementing the full CRUD operations, I'd just dump the ContentProvider, as you are gaining nothing by it."
Looks like this is caused by the latest changes to the ActionBar in the recent appcompat-v7 update.
Use findViewById and setSupportActionBar in your Activity onCreate to signal to the Activity which Toolbar should be treated as the Activity's action bar
It's usually recommended that you do that in a separate layout file and use include in your activity layout so you will only need to customize the Toolbar in one place if used in multiple activities
"Once you do that, all actions added in onCreateOptionsMenu will be added to the toolbar and it will be treated as the activity action bar."
Further customize the Toolbar as desired (Add child views etc.)
AsyncTask is an asynchronous task which means you usually do not know when it is completed and when it calls onPostExecute().
"When fragment is active (green box) the fragment added to back stack fragment goes to onPause, onStop onDestroyView."
In order to confirm my answer you can create an AsyncTask and call SystemClock.sleep(30000) inside your doInbackground.
That means you do not have any control over the number of calling AsyncTasks so watch out for
"For example: Going from Activity A -> B, you would put the overridePendingTransition call in the onCreate of Activity B."
"Keep in mind, if the user has disabled animation on a system level, you can't force animations to show."
The companion app doesn't have to be opened at all.
In your wear app onCreate send a message via the data layer.
"Implement a WearableListenerService in your existing app, it will listen for requests from the wear app."
Continue the messaging conversation in the service on your existing app.
The only solution I can see that doesn't involve an entity outside of the device would be to get the PackageInfo for your app and check the values of
"Additionally, you know approximately what date and time you create the version that introduces this new behavior, and you also know which version code it will have."
"Actually when you call x =  button1.getTop(); in onCreate() the Button view is not yet drawn and measured, hence the value of getTop is 0."
"In the example 3 code, it seems the orientation is fixed in the manifest..just leave it out empty (do not even set to portrait)"
"To force the orientation, add the below lines at the end of onCreate (after selectQuality(); line)"
Marker object cannot be retained through configuration changes because it doesn't implement Parcelable or Serializable interface.
The example works so when adding a marker it also adds the corresponding coordinates to an ArrayList as LatLng object.
First write super constructor in onCreate method  as mentioned below in your activity      class
in the constructor of the SQLite helper I add the new DB version
I've called their create queries in the onCreate method of the SQLite helper.
"  Also, I've added 3-4 totally new tables needed for new features."
Make sure the same new tables are created in onUpgrade().
"onCreate() is only run when the database is created for the first time, not on upgrade."
After both onCreate() and onUpgrade() the database schema (table structure) should be compatible.
Putting the CREATE TABLEs there in onUpgrade() is an option.
"but as a different resort, you can also re-set the interface when the fragment is recreated."
"You can't call getResources() before your activity class is ""officially"" instantiated (it's an instance method, and at that point you don't have an instance yet)."
According to the activity view cycle the menu is only created after onCreate.
The problem is that you are trying to retrieve an id for a view that is not in the hierarchy yet.
The best solution is to use onCreateOptionsMenu but even here R.id.menu_search will not return a valid id because the menu hasn't been created yet.
You can create a handler on your onCreate() and execute a postDelayed runable.
The code will be executed after the menu has been designed.
Race condition: More than one thread trying to get a hold of the database via getReadableDatabase() or getWritableDatabase().
What I think I should do: remove all Fragments in the onDestroyView()
"in that case, you should not perform the transaction again, because - it already happens automatically via the super.onCreate() Activity method."
not sure that you know it or not - if your your Activity is re-created without explicitly been destroyed previously from calling finish() or or pressing the back button - it means that it restored from previous instance state.
"in fact, if you'll perform the fragment trasaction in that case - you'll cause the same fragment  to be added twice (2 instances)"
you can know if currently onCreate()  been called from restoring instance state by checking if savedInstanceState parameter is null or not.
"you are not checking savedInstanceState, and performing the transaction anyway."
instead - you should do any object creations or initializations that depends on Activity context from the Fragment's onCreate() method.
when Fragment constructor is called - the reference to the Activity is still not initiated.
"in general, it's not recommended at all to override Fragment constructor, exactly like that you don't override Activity constructor, but only it life-cycle callbacks."
"Only some of the Google APIs are available via Google Play Services library (eg: maps, drive, ads etc)."
"in onCreate, do a HTTPS GET Custom Google Search Image Query using AsyncHttpClient and use Picasso library to show the first image result in your imageView"
add an ImageView in activity_main.xml for showing result from custom google image search
Activity => till android kills your process or the run method of your thread returns.
"if for example you declare your thread in onCreate method, if you change the orientation 5 times you create 5 different threads, that may cause memory leak."
in this pattern you can access your thread reference regardless of activity is recreated or not.
call this changeText()  method inside onCreate() method of your activity
"Those two lines have to be defined after setContentView, in the body of onCreate"
"About the compile time error you are getting, I took a look to the the code you posted in the link."
It makes absolutely no difference if you look for the View directly or if you look for a parent first and then the child.
In  a Fragment or Activity you can look for all the Views you will ever need in onCreateView() or onCreate().
When performance is critical see to it that you call findViewById() as little as possible.
"The problem is that you're setting the alarm in onCreate(), so every time the Activity starts, it sets an alarm for the current time, which fires immediately, starts the Activity, sets another alarm... over and over again."
"You should use the AlarmManager#setRepeating() method to set the alarm once, with a repeating interval of a day."
"Okay, so the trick is in the fragments onCreate method, you have to call"
"then all you have to do is override the onOptionsItemSelected in the fragment, and handle the action bar click there!"
It should correspond to one widget and the other will throw a ClassCastException.
3) in onCreate method set alpha of each layer correctly so just upper one has alpha value of 255.
4) set for each view of your FragmentStatPagerAdapter a tag that corresponds to drawable index that you declared in the LayerDrawable.
Put this code in the onCreate method before setting content view -
"call camera.takePicture(null, null, callback); from onClick() and define the callback outside the onCreate()"
Call stopService(intentOfYourService) at onPause() or onDestroy() and give the Intent you created at onCreate() (or elsewhere) to the parameteres.
Instance initialization (&lt;init&gt; in stacktrace) is too early to call activity methods such as findViewById().
Check if it is the first time with a method and then perform the action if that method determines that it is the first time.
"You've defined cloudinary twice -- once in the class, and once in onCreate()."
"When you assign a value to the one in onCreate() the cloudinary member in the class remains null, so your app crashes."
"Your test is creating the activity first (and triggering onCreate() too early), so your changes to the SharedPrefs have no effect."
"The process starts, triggering your Application's onCreate(), which also starts the service."
The problem is you are trying to find views that do not actually exist until onCreate() is called so these will be null.
move the initialisation of these to onCreate() and you should be ok.
You can declare the variables existance in the same scope as you are currently but instantiate it in onCreate().
"Ok so now we are away from Robotium and in to core Java, the issue you have now is scope, the thing is where you declare a variable and it is accesible is different to where you instantiate it."
extend service class and in onCreate method you can create multiple threads and each thread can take a messages from onStartCommand.
you should use normal service and do not use intentservice because you want to download simultaneously not one at a time.
i do not want to copy and paste the doc example because i think it is better to read all of the doc again.
I'm trying to delete a database entirely if onUpgrade gets called.
"  I know that I could just drop tables and such instead of totally deleting the database, but my db structure has totally changed and I would rather just call deleteDb(); and then onCreate(db); again."
"While that is not exposed through a getter method, you could hold the Context yourself in a data member."
"onCreate() is called on the event of creating the database; it is not ""create me a database""."
"Launcher apps calls startActivity with an intent [action = Intent.ACTION_MAIN, category = Intent.CATEGORY_LAUNCHER and flag = Intent.FLAG_ACTIVITY_NEW_TASK]."
"  If an intent is sent, when does it get sent to the onCreate() method"
  of a new activity instance and when does it get routed through
onCreate is called while creating a new instance of activity.
"onNewIntent is called if already an activity instance exists and no new instance need to be created, as in case of singleInstance, singleTask and conditionally singleTop (as described above)."
Methods you inherit in your Activity may not work before that point.
"Yes, you're right: The fragment lifecycle hasn't yet started when you're running onCreate() of your activity."
"First, get rid of the public static (or package-private static) members in your fragments and make them private and non-static."
"Other classes should have no business touching a fragment's internals, and making them static causes its set of problems, too."
do you think you could give some hints on how to do it
Define an interface -- I'll call it TableHelper here -- that has onCreate() and onUpdate() methods that match those on SQLiteOpenHelper
"Define N classes, one per table, that implement the TableHelper interface and provide the create and upgrade logic for that table (along with whatever other business logic you want to have on those classes)"
"Have your SQLiteOpenHelper define a TableHelper[] containing instances of your TableHelper classes, and have it delegate onCreate() and onUpgrade() to those TableHelper instances by iterating over the array"
Before onCreate() there's no window yet for the activity and you'll get the NPE.
Before setContentView() there's no view hierarchy to search from and a null is returned.
Get the String data in onCreate first and then use it in onClick.
"As far as I know, adding the markers cannot be done outside the UI thread."
Try and use the map directly in onCreate() of your Activity.
"As long as the call to getExtendedMap() is not null, you should be fine."
Look for something consistent in the server's response to the authentication attempt that the WebView can detect and branch on.
(In onCreate you need to say something like webView.setWebChromeClient(new MyChrome());)
Putting the code into a custom Application's onCreate function solves the issue.
The activity object you're passing updates to is different from the one that displays your UI.
In this case you'd get an NPE at textView1.setText() since onCreate() has not been run.
Their lifecycle methods won't be invoked and they won't be good for anything.
"You're calling findViewById() too early when initializing an activity settings object, likely a member variable."
You can call activity functions really only in onCreate() or later.
The problem is that you are trying to unregister more than once broadcast receiver.
Please take a look into activity lifecycle in Android - that should know every Android Developer ;) - here everything you need
Let us understand why the lifecycle methods are called multiple times.
Hence : onCreate - onStart - onResume - onPause - onStop - onStart - onPause.
After the screen turns on onStart and onPause are called again.
Similarly for onStart it would be onStop and for onResume it would be onPause.
"In my code, I've only called setController() twice: from the onCreate() and onResume() methods in my activity."
"Depending on the structure of your code, you'll have to do some general tidying up."
"First of all, you really shouldn't send Toast messages from a Service or from any task that wasn't initiated by the user a very short time ago."
"Thus, if you want to post something to the UI/main thread from a service (from any thread) then you should create the Handler in, for instance, the onCreate() method; because onCreate(), and usually any Android callback method, is called on the UI thread."
in your activity constructor (as you state in your question) when you should be making it in the activity's onCreate method.
at first set isLoading = false; in the constructore or onCreate method
"You need to have a Context and then context.getSharedPreferences() , you can get it via the adapter's constructor."
Pass SQLiteDatabase as an argument to SeedData(SQLiteDatabase db) in onCreate method
Move your code from onCreate to onActivityCreated instead of trying to getActivity @ onCreate.
"That's because the fragment can be created when the activity is not yet ready, that's when you are trying to use it."
For updating the onCreateOptionsMenu inside the fragment you need to call the setHasOptionsMenu(true); inside the onCreate method of the fragment.
Otherwise you won't be able to update it when you call getActivity().invalidateOptionsMenu();
"Assuming I understand your question correctly, I think I found a way."
"Here, we anonymously subclass DatePickerDialog to override onCreate() and set a transparent background for the window."
You could also do this with a custom theme instead.
onCreateView() is the Fragment equivalent of onCreate() for Activities and runs during the View creation.
"If the database file didn't exist, the onCreate() callback is invoked so that you can set up the database file."
The first sqlite open helper with the same database file is accessed.
The other sqlite open helper with the same database file is accessed.
"A database file with the given name already exists and is of the correct version, so no onCreate() or onUpgrade() gets invoked."
Put both table's creation statements in the same helper onCreate() method.
A solution that will not require you to create a custom action bar.
"I've asked a variety of questions similar to this and done lots of googling, and I've managed to piece together a solution from a variety of places."
First of all there's no need to call the initState(savedInstanceState); method in both the onCreate() and onCreateView() callbacks.
in onCreate method because activity context available in Activity methods.i.e.
will not be called until the FragmentManager has actually committed the change.
Now in your onCreate() you can call getArguments() to get the bundle and retrieve the URL which was passed by your activity.
The best option would be to save a boolean inside of your onSaveInstanceState and then check that state inside of onCreate.
"Just like an Activity, Fragments have a specific lifecycle, and are not ""created"" like simple Java objects."
Only then will it go through its lifecycle methods (e.g.
"You should set the arguments this way, and should do so before committing the FragmentTransaction -- however, you could technically do it right after committing the transaction with no ill effects."
"Your question seemed interesting to me, so I started digging."
"When you initialize mHandler in the MyService's onCreate() method with mHandler = new ServiceHandler(), the Handler is associated with the message queue of the currently executed thread."
  If I start the app manually everything works fine - messages are received by the Handler in my service.
"mHandler process Messages from the queue that, in its turn, is handled by Looper which is looping."
"Generally, there's nothing wrong in calling a method when initializing a variable in Java."
The code will NPE because the activity Window has not yet been set up.
"In Android activities in general, you shouldn't really be doing anything at runtime before onCreate()."
With that little information there is not much we can do to help.
It is in the missing run() method where you should add the image processing you want to perform.
"When onCreate() is called on your fragment, it registers to your sticky event."
"At that point, your fragment is probably attached to your activity, but onCreateView() has (probably) not been called, so your TextView doesn't exist."
"I've never seen that kind of register/unregister pairing, but it should work."
"In theory you can do whatever you want, if it works."
A Fragment is a class that implements the onCreateView method to
supply a View hierarchy that can be displayed by an Activity.
"After the method that used the commit, usually the Activity's"
onCreateView and the Fragments View hierarchy is added to the
"When screen orientation changes, Android restarts the running Activity (onDestroy() is called, followed by onCreate())."
"To properly handle a restart, it is important that your activity restores its previous state through the normal Activity lifecycle, in which Android calls onSaveInstanceState() before it destroys your activity so that you can save data about the application state."
You can then restore the state during onCreate() or onRestoreInstanceState().
"However, you might encounter a situation in which restarting your application and restoring significant amounts of data can be costly and create a poor user experience."
Inside your Activity instance's onCreate() method you need to first find your Button by it's id using findViewById() and then set an OnClickListener for your button and implement the onClick() method so that it starts your new Activity.
You need to call setHasOptionsMenu(true); in onCreate() of your fragment.
"Setup your options menu from within onCreateOptionsMenu(Menu menu, MenuInflater inflater)"
"Moreover, To get your Action bar instance, write getSuppportActionBar() and then make whatever changes you want to do."
For backwards compatibility it's better to place this call as late as possible at the end of onCreate() or even later in onActivityCreated() or something like that.
onCreate() when activity is first created ( from a1 to a2).
There are multiple ways you can infer if you have arrived at this activity by back key press.
Set a boolean in oncreate that says on onCreate is called.
Start C activity by calling startActivityForResult and when you return from C onActivityResult will get called.
"onCreate() is only called once (when the activity starts), while onStart() gets called everytime a user reenters your activity (i.e."
SQLiteOpenHelper sets up a new database file by calling your onCreate() callback and migrates old database files by calling your onUpgrade() callback.
The difference is only in how the schema and initial contents are set up and how version migrations are done.
SQLiteAssetHelper sets up a new database file by copying a file from your assets and migrates old database files by running upgrade scripts from assets.
The Service's context isn't fully set up yet at that point.
"In onCreate(), register the service as a listener to SensorManager (very much as you do here)."
"When your activity runs, send an Intent to start the service (see docs)."
"Your EditText are null, you need to do this before your button click code"
"When you pass data from one activity to another using a Bundle, the data is received inside onCreate() method of the second activity not inside onActivityResult() unless you've specifically implemented that."
Check this answer on how to start another activity and how to pass data to another activity : https://stackoverflow.com/a/20170125/1239966
"You will need to add the first YouTubeVideoFragment in onCreate() with a FragmentTransaction, and when the user clicks the button, the code you already have in testClick() should work."
"First, I would try switching away from grantUriPermission() and simply put the FLAG_GRANT_READ_URI_PERMISSION on the Intent itself via addFlags() or setFlag()."
"If for some reason that does not work, you could try moving your getCallingUid() logic into onCreate() instead of wherever you have it, and see if you can find out the actual ""caller"" there."
"i typically override the animation from within the onCreate() function of the activity being started, and this seems to work well."
the caller should just startActivity() normally; don't use overridePendingTransition() or FLAG_ACTIVITY_NO_ANIMATION or anything else.
Please see my sample project at https://github.com/sveinungkb/wear-test for a working template.
"Call the displayFragment() method in the onCreate() callback, only when the passed in Bundle is null meaning that the Activity is not being recreated(if the Activity is recreated then the fragments will be made available by the system)."
"When you call view.getMeasuredWidth() in onCreate() or onCreateView(), the view has not been drawn yet."
onStart() : Called when the activity is becoming visible to the user.
assign the adapter to ListView in onCreate() or onResume() of your activity.
"In your activity's onCreate or onRestoreInstanceState, pull the tag out of the saved bundle and start a new fragment of that type."
(This will probably be easiest to do if you keep a variable that automatically updates every time the fragment changes.)
"Initialize your RequestQueue, using Volley.newRequestQueue(this);, in onCreate() after the super.onCreate() call."
"You are trying to use your Activity from an initializer, which frequently causes problems like this."
"That is because you are starting the activity again, onSaveInstanceState means that when you are recreating/pausing the view/activity (ex."
"screen rotation) it will call the onSaveInstanceState() method and then call the onCreate() which by then you'll get your data that was saved, but in your case data will not saved when you are trying to start the app again."
The first (onStartCommand()) is called when your Service begins to do its work.
onCreate() has completed and it is ready to get to doing what needs to be done.
The second (onBind()) is called when another Thread registers to connect to the Service so that they can communicate.
"Try this in your Activity's onCreate(), it will remove that bar, and it is called ActionBar."
The only way I could avoid this was to not retain the fragment instance.
"Your messages that you send to that DownloadHandler will only be passed to the handleMessage() method when the main application thread gets around to it, after having processed all other messages on its message queue."
"You read the data just once, but need a context to do so."
in onCreateView() set the text to mItem.desc instead of mItem.content
in the Callbacks interface as well as it's anomymus implementation change the signature of onItemSelected(String) to onItemSelected(int)
You call the fill...() methods in onCreate() that is triggered by a call to getWritableDatabase() or getReadableDatabase().
That causes the recursion: you're calling get...Database() while a previous call to it has not yet completed.
Use the SQLiteDatabase passed in as an argument to onCreate() instead.
"When the activity is recreated after a rotation, it is one of the first methods called, even before the Activity is fully created (i.e."
"super.onCreate() is FragmentActivity.onCreate(), which restores any previous fragments after a rotation."
"mImpl.onCreate(savedInstanceState) is ActionBarActivityDelegate.onCreate(), which reads the mHasActionBar variable from the window style."
"The fragment that hosts the ViewPager and the child Fragments that are created by your adapter must also call setHasOptionsMenu(true); in their onCreate() method's, so that all of the option menu events get passed down to the child fragments and on to their children and so on."
Anyone doesn't know how to create a Service instance correctly can see this issue.
"Or you can also access this in Activity onCreate(), if Bundle object is contains curTab."
there's a very likely chance that it's a different instance of your activity.
Making it two instances of your activity class running with two separate onCreate
"you can check that by pressing the multi-task button on the device and see if you have your application screen-shot preview two times: one with your own app icon, and the other with the other app (e.g."
"so that it gets declared as global, then do this in onCreate()"
Your AsyncTask has a reference to mess which is an object of type Messaggi2.
"The Android system has no awareness of this object; it has called none of the life cycle methods, such as onCreate() where the activity's layout would typically be inflated."
"You attempt, inside your AsyncTask, to create a new instance of that class."
"In your case, the Looper is executing onCreate when you call join."
"When you call runOnUiThread, the Runnable is enqueued to the looper, meaning it will be executed after the current thing being run by the looper is done, and the queue is empty."
That means that your runOnUiThread will be enqueued for after that.
Using BitmapFactory.decodeFile(File) leads to OutOfMemory issues when decoding large pictures
"If all of the pictures will be the same resolution, and your minSdkVersion is 11 or higher, then allocate the Bitmap for it when your process starts up (e.g., in onCreate() of a custom Application class), and use that with inBitmap on your BitmapFactory.Options."
"The Dalvik garbage collector is a non-compacting collector, and so the heap will get fragmented into lots of smaller blocks of memory."
"Your attempt to allocate the Bitmap should succeed early on, before your heap gets fragmented, if the image can fit in the heap in the first place."
You shouldn't put code to check things like this in onCreate() because everything might not be drawn yet.
You can use the Application as a Context only in onCreate() or later.
"First, you need permission to know whether the device is connected to the web or not."
After this you should create an method or put the following code into the onCreate() method to show an alert.
Checking if this method returns null should be enough to tell if an internet connection is available.
"You didn't call the Activity's onCreate() method, i.e the super class' one."
The reason why it works if you do it inside onCreate() is because Activity has a findViewById().
Unicorns and kittens will die for every millisecond the UI Thread is frozen.
Because this callback is not included in the lifecycle if the Fragment goes to the background and comes to the foreground again.
In onCreateView and any following callback you have to determine when you wanna call the network.
It will only be called if the Fragment is created.
"If the context is needed, onAttach() is the better choice."
Because onAttach() will get the Activity as a parameter and is like onCreate() independent of the foreground/background lifecycle.
"You manage the tables yourself with the given database lifecycle callbacks (onCreate(), onUpgrade())."
"Quickly reading one could interpret that the author advocates creating a separate database helper for each table (I did at first), but that's not the case."
However its lifecycle doesn't kick in until it is attached.
"Using SharedPreferences is a way to save and retrieve key, value pair data in Android and also to keep session all throughout the entire application."
"Finally, you will have to create an instance of this SessionManager class in the onCreate method of your activity class and then call the createLoginSession for the session that will be used throughout the entire app"
The source code to IntentService shows that it creates its own HandlerThread in onCreate().
"The tutorial is probably outdated, attempting to create an activity-based UI instead of the fragment-based UI preferred by wizard-generated code."
"onCreate() is too early in the lifecycle to find it in the activity view hierarchy, and a null is returned."
The view is in the fragment layout (fragment_main.xml)  and not in the activity layout (activity_main.xml).
"As a side note, the fragment layout will eventually be a part of the activity view hierarchy and discoverable with activity findViewById() but only after the fragment transaction has been run."
My question is how to override onCreate method without calling super.onCreate()
"Please call super.onCreate(), typically as the first line in your onCreate() implementation."
"You can also make custom animations, ""regardless startActivity method"", but in using the lifecycle of activities: I mean like Vine when you call the enter animation into onCreate() and the out animation into onPause()."
"You need to define your ""slide up"" animations from the linked question, and some new ""slide down"" animations that reverse the process."
onCreate() is not called every time the activity is shown
onDestroy() is not called every time the activity is taken away
"call super first, to init all object internals  before you code may use it, while on onPause(), onDestroy() first cleanup your stuff then call super to let superclass do its job too, otherwise your code may try to depend on stuff that is no longer available after super cleaning completed."
Lifecycle methods on all Android components are called on the main application thread.
  If that were to happen services will end when application exits
Bear in mind that PreferenceFragment should be used in post Honeycomb Android Versions as a replacement for PreferenceActivity.
"  There is a simple reason for this, onCreate() provider is called"
1 Move your logic from onCreate to attachBaseContext in your Application.
You're calling setRequestedOrientation to landscape as soon as you start your Activity (onCreate).
"In the subclass, when you call super.onCreate() the code will be executed."
You need to create a Base activity which does all the common Drawer navigation stuff .
Create a common Layout with DrawerLayout and place a FrameLayout and ListView as child
You can start a new ProggressDailog in SecondPageActivity from onCreate() or onResume() method.
onCreate() is called when you call getWritableDatabase() or getReadableDatabase() on the helper and the database file does not exist.
"If the file is already there and the version number is the requested one, no callback such as onCreate() is invoked."
"For what it's worth, it's also a bad idea to catch exceptions in onCreate()."
"If the method returns successfully (doesn't throw), the framework thinks the database was created successfully."
You shouldn't be doing any initialization (and especially not Fragment transactions) in the constructor of an Activity.
onPostExecute is called on the UI thread after the background task completes its work.
Now you can create the adapter once (in onCreate()) and just swap the list whenever it's appropriate.
"For an OtherActivity that is part of your own app, your MyActivity instance should be left alone, unless you finish() it yourself."
"Assuming you do not finish() it yourself, onCreate() should not be called on your MyActivity instance."
You need to set the layout to the activity first and then initialize views.
"From what you describe, I would assume that your affected users ""close"" (actually hide) the app by pressing the home key."
"Assuming that you process the NFC-related intents only in onCreate(), you would normally not run into the issue you described when starting your activity from the history as the onCreate() method would not be called if your activity still existed in the background."
Later they are opening the app (or rather that activity) from the history (long-press home key).
"app has been manually killed, app has been killed by the system to free resources, etc), re-launching the app from the history will cause your onCreate() method to be run again."
As Android rebuilds the activity stack and re-sends the original intents (i.e.
  The system calls this when creating the fragment.
"Within your implementation, you should initialize essential components of the fragment that you want to retain when the fragment is paused or stopped, then resumed."
  The system calls this when it's time for the fragment to draw its user interface for the first time.
"When you create a Fragment somewhere else in your application, onCreate() method is called."
You can return null if the fragment does not provide a UI.
"When fragment has to be drawn for the first time, onCreateView() is called and this method returns a created View."
"In onCreate, initialize all this data (empty container), initialize adapter and then execute the AsyncTask."
Declare an instance variable (container) for this data and adapter (if you use any).
"In onCreateView, prepare the view to return - adapter etc."
"After the system calls onCreateOptionsMenu(), it retains an instance of the Menu you populate and will not call onCreateOptionsMenu() again unless the menu is invalidated for some reason."
"However, you should use onCreateOptionsMenu() only to create the initial menu state and not to make changes during the activity lifecycle."
invalidateOptionsMenu() was added in API 11 to give us the ability to force onCreateOptionsMenu() to be called again.
"When an event occurs and you want to perform a menu update, you must call invalidateOptionsMenu() to request that the system call onPrepareOptionsMenu()."
In case of ICS and Honeycomb onCreateOptionsMenu() is called after onCreate() and onPostCreate() while in Gingerbread and earlier versions it is called after onCreate() but before onPostCreate().
"Note that if the activity is already running, onNewIntent() will be called, instead of onCreate(), to deliver the NDEF Intent to you."
"Hence, you will need to handle the NDEF Intent in both onCreate() (if the activity was not already running) and onNewIntent() (if the activity was already running)."
Move the initializations of both res and letters to your onCreate() method and keep the declarations where you currently have them.
Call getIntent() inside onCreate or in another callback of the life cycle.
First initialize your MyTextView in your onCreate and then set the text which is returned from your getDeviceName() using setText() method of it.
"First, the onPreExecute() function would be executed on the main thread."
"You need to initialize it before you can call it, ideally in your onCreate() function."
You cannot call the edit() function of myFoodList yet because it has not been initialized and is null.
"To counter this, you can save the state of the activity using savedInstanceState, maybe save a boolean that the fragment has been created once, and then check it in onCreate whether to create the fragment or not."
"Might not be the best option, but it works and it's simple."
onToggleClicked is a public method and needs to be attached to your Activity.
You cannot use this method as an inner method inside onCreate method.
Yes you need it and you also need to pass a non-null valid Context as an argument.
Clear app data or uninstall it to remove it and make the database helper onCreate() create set up the tables for you.
Possibly you have an older version of the database file around.
Move assigning tweenAnimation to a point in the fragment's lifecycle where the activity will exist like onCreate
Accessing this will then result in a NPE (if loadAnimation hasn't already thrown one)
My listview stopped scrolling as well with the X16 update.
Simply have onCreate() and onUpgrade() on your SQLiteOpenHelper delegate the actual work to the per-table classes.
"However, the table creation and upgrade logic needs to be driven by a single SQLiteOpenHelper class."
You cannot be setting the entries and entryValues of the ListPreference in an onClick event when there are no entries and entryValues to begin with.
Just uninstall your app or clear its data to remove the old database file and make your onCreate() recreate the database on the next run.
Chances are that you've added a column but the test device still has a database file without that column.
"The Views in your Fragment's layout xml are being inflated into the Fragment's View hierarchy, which won't be added to the Activity's hierarchy until the onAttach() callback, so findViewById() in the context of the Activity will return null for those Views at the time that onCreate() is called."
