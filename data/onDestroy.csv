text
"viewLifecycleOwner is tied to when the fragment has (and loses) its UI (onCreateView(), onDestroyView())"
"In your current code, if onDestroyView() is called, but onDestroy() is not, you will continue observing the LiveData, perhaps crashing when you try populating a non-existent RecyclerView."
(1th answer: this answer only works on limited situation.it's not a complete answer)
"so, we are going to use this returnee in order to restart app."
We put restart action in both onDestroy() and onStop() in order to make sure app will be restarted again.
"it's because , it makes sure that onDestroy() and onStop() will be invoked."
"Fragment implements LifecycleOwner which maps its create and destroy events to the fragment's onCreate and onDestroy, respectively."
"Fragment.getViewLifecycleOwner() maps its create and destroy events to the fragment's onViewCreated and onDestroyView, respectively."
  From the documentation of getViewLifeCycleOwner it seems that making this change may allow us to remove the removeObservers() call in each fragment's onDestroyView().
"Otherwise you might get updates when the view hierarchy is invalid, which may lead to crashes."
"Basically, in order to retrieve a ViewModel in Activity one should call ViewModelProviders.of(this).get(SomeViewModel.class)."
A similar trick is used for storing a ViewModel for a Fragment.
"When using RxJava in Android I normally ""dispose"" all disposables in onDestroy."
It is safe enough to dispose of them in onDestroy because even if onDestroy never gets called you can safely assume that the system has killed your application process or the component that subscribed to the Observable.
"The reason I never dispose a subscription in onSuccess or onNext is because for example, in the case of a Flowable...onNext can be emitted multiple times and it wouldn't make sense to dispose the subscription."
You can determine if the activity is finishing by user choice (user chooses to exit by pressing back for example) using isFinishing() in onDestroy.
Or create CompositeDisposable in your presenter and add each disposable there.
You're basically causing a (temporary) memory leak by not cancelling the coroutine.
"You're updating values in an Activity that has been discarded, but only kept in memory due to your coroutine keeping a reference to it."
"The above answer worked , but i solved it without inheriting CoroutineScope class by just using ...."
Dispatchers.Main is important cause you cannot update the UI in any other thread than main.
You could store the previous brightness in a variable within the Fragment.
"When the Fragment is being removed, it will call onDestroy(), which is a good time to reset the brightness."
"Declare a interface inside fragment and implement it in your activity and send response to activity inside onDetach(),onDestroy or onPaused method of fragment,  any of them which suits you."
"finishAffinity() :  finishAffinity() is not used to ""shutdown an application""."
You have no control over this (and that is intentional).
"when you use subscribeWith(), it returns Disposable it self through which you can dispose the subscription at any time if you want."
more similar to the way you did it currently like: (Notice that the result of subscribeWith() is directly assigned to your disposableSingleObserver variable
"You just leaked the Timer, because you did not cancel the Timer in onDestroy()."
Change your onStartCommand code to check action in intent and do startForeground or stopForeground(false);
Your problem might be that Android Oreo effectively banned implicit broadcasts.
The easiest way for you to fix this is to use an explicit broadcast instead of an implicit one.
"As we will cancel the job in onDestroy() during swiping in ViewPager, we should recreate the job)."
"(I tried to write private val job: Job = Job(), but bumped into problem that in ViewPager you will create Fragments and their jobs."
For default implementation of LifeCycleOwner indicates that activity gets it's DESTROYED state once onDestroy() method is executed &amp; after onPause() it follows reverse order of LifeCycle state RESUMED -> STARTED -> CREATED -> DESTROYED.
"You solved your immediate problem by adding the dependency, but let me add a note on your usage of GlobalScope."
Fused Location Provider will give the location if at least one client is connected to it.
"You are implementing the wrong concepts.., which creates problem.., To tackle it .. you are again implementing wrong things.."
Setting them to null does nothing because the threads are still running and the virtual machine will keep track of them while they do.
"Let me start by saying that @madlymad has the right idea, and you should create a BaseFragment class if you haven't already."
"However if for some reason you can't or don't want to, you can instead set the orientation in the Fragment's onAttached(), onCreate() or onCreateView()"
"Through the source code, we know the ViewModel binds with HolderFragment."
you can from the code in class ViewModelProviders to find it.
"When the fragment finished, it cleared; when activity recreate,the fragment's onDestroy() will not be invoked, because"
observe a LiveData object as it is not a LifecycleOwner
"Use observeForever() on the LiveData, manually unregistering via removeObserver() when appropriate (onDestroy() of the service, if not sooner)."
"Bear in mind that standard service limitations apply here (e.g., services run for ~1 minute on Android 8.0+ unless they are foreground services), so it may be that you need to consider other approaches anyway."
"If task is not running cancel on onStop(), Else task is running, then on onDestroy()."
try to destroy webview in onDestroy()  method because WebView Client or Chromium client is loading data even after your activity or fragment destroyed.
"You need to use a NotificationChannel for Android O API 26 and above, otherwise you'll get the error you have experienced."
"In your onStop() callback, you'll need to call stopSelf() within the service."
"Your fragment receives a callback, but can be in any state before onDestroy, meaning the UI may have been torn down already."
onSaveInstanceState() is going to get called by the activity when it is shutting down (except in instances where it is explicitly closed by the user).
For that you should unsubscribe your fragment in onPause() or onStop() or onDestroy().
The code that you are using in your onDestroy method is not needed there.
If destroy is called your acitivity will be removed from the stack and is free for gc anyway with all the resources in it that are only referenced by the activity.
You could try and explicitly call for finish() in activity then onDestroy will be called and see how the situation will change.But then the activity will be removed from stack.
OnDestroy doesn't always get called that's why your method may not be called at all.
"A wonder if it is legitimate implement the observer pattern by hard references, if I remove the references during onStop(), or onDestroy()."
The observer pattern implemented as WeakReference seems to be no alternative to your suggestion.
"As a conclusion, you create a single database connection, use as many references you need, add the listeners accordingly, remove then according to the life-cycle of you activity."
"You need to remove it, so the listener does not stay running in the other activity lifecycles like onDestroy()"
What you can do here is have all the subscriptions references used in your Activity in a CompositeDisposable (RxJava 2) or CompositeSubsciption (RxJava) object.
"Just make sure you can always abort or ignore the result when you don't want the result, for example if an Activity's onStop or onDestroy method is called."
You cannot rely on it being called all the time.
There is a case when the app go from onPause() to onCreate() without onStop() and onDestroy()  is when another app with higher priority needs memory as you see the illustration.
"  suitable operations to perform during onStop(), see onStop()."
"It's not enough just to ""Move response listeners to their own separate classes""."
"2) Set mContext to null in listeners, when Activity's onDestroy() is called."
"As for UI thread, you'd use the retained fragment (or Activity/Fragment onCreate()/onDestroy()) as you normally would, but using open/close as well."
I'm not sure what your onPause() and onStop() are meant to do.
It's a good practice to dispose CompositeDisposable in onPause or onDestroy to avoid such problems.
"a ListView, then close the cursor in the activity's onDestroy method."
If using the Cursor for what I'll call more complex processing e.g.
In my case I was targeting API level &lt; Oreo and the invisible overlay method in Ch4t4's answer does not work as it does not throw an exception.
"It is important to note that, as of the current implementation (Android O), the system will not de-duplicate registered listeners before calling back."
"No, the Activity A will not remain in the backstack if you call finish()."
"Usingfinish(), it will call onPause(), onStop() and onDestroy() in this order."
"There is the need to remove listeners because the mAuth will keep of keeping track of all the listeners you added, in order to notify you when something happens."
"onStart and onStop correspond to each other, while onCreate and onDestroy correspond to each other."
"It would be a good idea to do your cleanup there, instead of onDestroy()."
"You may also notice that if resources are required, your app could be killed as early as onPause()."
"  Returns true if the final onDestroy() call has been made on the Activity, so this instance is now dead."
the following are method which your to perform any task before Activity is going to become invisible.
onDestroy() - Perform any final cleanup before an activity isdestroyed
"isFinishing - Check to see whether this activity is in the process of finishing,"
You can avoid these issues by properly adding / removing your shorter lived objects (e.g.
"Currently you're calling release in onStop() which will null out all the important pieces of the player, but not the exoPlayer field (and destroy any state that you aren't keeping track of yourself)."
You could also move the release() call to onDestroy() but only if you know you're reinstantiating everything correctly.
The error occurs when Activity gets finished before dialog successfully dismisses.
Alternatively you can dismiss your dialog in onPause() or onDestroy() of the activity.
If the reason of not using Intent that you don't want the the user to re-enter the previous activity
"You can use onDestroy() override method, Sometimes it can also be called if the activity is being killed by the android itself so you can add"
  If you want to do some code while the activity is finishing
Inside onDestroy() method which checks whether the application is closing by the call finish() returning true or otherwise by anything else returning false then you can easily specify your code for each situation.
First of all let's understand what's going on with the documentation you quoted.
"3,4,5) onDestroy() will not be called only if the process hosting the entire application is killed."
2) On pre-Honeycomb only onPause() is guaranteed to be called (as stated by the earlier version of Activity's javadoc)
"When the process is killed, all resources allocated to it are freed, therefore there is no risk of memory leak in this case."
"Important note: since releasing resources in onDestroy() will not cause memory leak, it might look like a good idea to put all the ""releasing"" code there."
"Activity can remain in this ""stopped"" state for quite a long time, and will be started again if the user returns to the application."
"When Android runs out of memory, it starts killing the processes in order to free the memory consumed by them."
"Therefore, I strongly advice releasing all resources in onStop() method."
"Corollary: As pointed out by @Juan in his comment, the above important note has an equally important, but not so evident corollary: onStart() should be the only method in which resources are being allocated."
"After checking the docs a bit more, it looks like you're falling into this scenario from the onCreate docs: https://developer.android.com/reference/android/app/Activity.html#onCreate(android.os.Bundle)"
"  You can call finish() from within this function, in which case onDestroy() will be immediately called without any of the rest of the activity lifecycle (onStart(), onResume(), onPause(), etc) executing."
FIX: Override onResume and call videoView.start in there and override onDestroy and onStop and call if (videoView.isPlaying()) videoView.stopPlayback in there
"You're calling unregister() in onStop(), so you do not receive events when MainActivity is in the background."
"To receive events even when the Activity is in the background, you should register in onCreate() and unregister in onDestroy() (rather than in onResume()/onStop())."
"No one, except you, can tell whether you should or shouldn't register Application as a listener on EventBus - it depends on your app's use cases."
their lyfe-cycles are identical (Application can be treated as Singleton object)
After more research I've found that this question was already asked and answered.
"The file that you can get from the guide are outdated, and should be instead downloaded from github."
disposeWhenFinished it's a more elegant solution that works better than a dispose.
"While it was true that all my background tasks did call realm.close(), one of them called it too late in it's lifecycle."
"The problem was that GPS service is initialized at the launch of the App as an Android Service, which is rarely destroyed."
After the comments of @EpicPandaForce and reading his articles about using realm properly.
The framework does not know about any other Threads you may have started-  its your job to kill them in onDestroy().
That is because - you are unregistering the broadcastreceivers in both the method onStop() and onDestroy().
Delete the files in onDestroy if isChangingConfigurations() is false or isFinishing is true.
It might be better if you called delete() in onDestroy() to insure that your code works even if app is destroyed by system.
Technically speaking onAttachedToWindow is called after onResume(and it happens only once perlifecycle).
ActivityThread.handleResumeActivity call will add DecorView to the current WindowManger which will in turn call WindowManagerGlobal.addView() which than traverse all the views and call onAttachedToWindow on each view.
"Activities need to handle configuration changes, such as when the screen is rotated, or the user changes locales, or the device enters night mode."
"Retained fragments work great for this, as you can then call unbindService() in onDestroy() of the fragment, so that when the activity is ""permanently"" destroyed (e.g., user presses BACK, you call finish()), your binding can be released."
"With all that as background, on to your specific concern."
"According to this post and the Android documentation, the setResult(int, Intent) method must be called before the activity is finished (i.e."
"It doesn't new on Xiaomi because Xiaomi has a feature called app permission, where user has to allow the app to start automatically (Service)."
"Don't try to restart the same Service inside onDestroy() instead use START_STICKY inside onStartCommand(Intent intent, int flags, int startId) method."
In Fragment lifecycle methods for destroying calls with this turn
"addToBackStack(null) method adds fragment to backStack, i.e it saves fragment instance and when fragment became invisible, system calls fragment onDestroyView() method because view destroyed, but after it system doesn't call method onDestroy() because fragment instance saved in backStack and there is reference on fragment instance and it doesn't destroy."
"Your BatteryChecker can implement ActivityLifecycleCallbacks and call registerActivityLifecycleCallbacks in onCreate when you create your Application class, in this case your custom class will receive all Activity lifecycle callbacks."
"It's of arguable benefit because you still have to use Activity events, but you could attach to the Activity lifecycle in your activity's onCreate() and detach from it in its onDestroy() events too."
"As specified in the Android documentation, it is not guaranteed that onDestroy() will be called when exiting your application."
"  ""There are situations where the system will simply kill the activity's hosting process without calling this method"""
"Most of your application code will run here onCreate, onPause, onDestroy, onClick, etc."
Let me know if I can help you any further.
"When you register the listener, you get back a handle to the listener."
"The lifecycle methods of the service onCreate(), onStartCommand(), onDestroy() are all called on the main (UI) thread."
"There is no onDestroy() method on the Application object, the only similar event is onTerminated() and it is not being launched on production devices."
"Once the system kills your app, the Service will automatically be killed, so no problems at all."
onDestroy() may or may not be called on any given activity or service.
"The general rule is that either onDestroy() is called, or your process is terminated, or your code crashed."
You may or may not be called with onDestroy() when that occurs.
"Your process may be terminated for any reason, at any time, by the user or by the OS."
"While you may be able to improve your success rate a little via onTaskRemoved() on a Service, this itself has proven unreliable, and it will not cover all scenarios."
"Hmmm this question is trickier than it looks, the transparent Activity causes problems."
You just need to make sure you call unregisterReceiver() in onDestroy() rather than in onPause() {onStop()}.
"its onPause() {onStop()} will get called, but it can still receive broadcasts."
"Generally, Anonymous classes have a strong reference to the enclosing class instance."
"What you should do is tag all the requests you are sending with the Activity instance, and cancel all the requests at onDestroy() callback of Activity."
Those Runnables and messages have a reference to the target Handler.
"when the method returns the Activity's instance won't be immediately killed (see), the memory cannot be GC-ed because of the implicit reference* to the Activity."
"You can maintain local references of your firebase reference and listener, than you can do a ref.removeListener(listener) in onDestroy of your Activity."
When there is reference that holds the activity from being Garbage collected.
Like for example a static variable that holds an activity in its arguments or by its method.
"As with lots of things in computer programming, there is no single ""correct proceed"" for the timing of closing a SQLite database (via close() on SQLiteOpenHelper if you are using that, or close() on SQLiteDatabase otherwise)."
"If only a single component uses the database, there is nothing wrong with triggering opening the database in onCreate() and closing it in onDestroy()."
"However, there is nothing especially wrong with the open-use-close approach if you are sure that only one thread at a time will be working with the database."
"After all, if that is the only component that needs the database, you do not need the database when the component itself goes away."
"  Close your db in onDestroy() Comments: ""OnDestroy() does not get called always!"
"If onDestroy() does not get called on a component, either you crashed with an unhandled exception in that component, or your process was terminated."
"The latter scenario is not a problem (again, this is how a ContentProvider works, since a provider is never destroyed)."
"When Android wants to reclaim resources (or just because Android likes to tidy up), it will usually just kill off any OS processes that are not hosting foreground activities or foreground services."
"You will not be warned about this, so there is no way to ""catch"" this behaviour."
To stop pausing of music when app gets to background.
The playback should itself stop it on back press (I'm almost certain).
"In your onNavigationItemSelected method, you are replacing the current fragment with fragment even in cases where fragment is null, which has undefined effects."
(and then leave out the fragment transaction below this point).
"Note: I am not an official Realm person, but I've been using Realm for a while now."
"When you call realm.close() on a particular Realm instance, it invalidates the results and objects that belong to it."
"(It's not as important to close the Realm instance on the UI thread unless you intend to compact it after all of them are closed, but you have to close Realm instances on background threads.)"
"As it turns out when you call stopService(Intent), though the onDestroy() method of the IntentService is called, the background thread will continue to run until it's complete and deliver a result to the receiver."
Service with START_STICKY in retrun onStartCommand() will start again automatically you dont need to start it again in onDestroy()
If noHistory is set the ActivityCompat.requestPermissions call causes the onDestroy of the calling Activity to be executed thus destroying.
As it isn't saved in the history due to the noHistory it no longer exists and the app is essentially closed when permission dialogue is dismissed.
"As there is currently no way to provide a context to listeners, need to keep track of all attached listeners and remove them as shown by David in the answer here: https://stackoverflow.com/a/33782474/1820644"
Step 3: Remove a listener for the view holder when a view is recycled.
"Like in example we have used value of 'key' under the child events as the key of a Map, but you can put events/&lt;key&gt; as the key of a Map and remove in one go in onDestroy with mRootRef.child(""&lt;your_combined_key_from_map&gt;"").removeListener(listener)."
Alternatively you can put a full path instead of just a key as the key of a Map.
  Note: do not count on this method being called as a place for saving
A Service may or may not be called with onDestroy().
Override the onDestroy() method and in this method Just call finish() and Runtime.getRuntime().gc() methods...
I've solved it before by keeping a boolean value in the Activity that keeps track of whether or not the Service is bound.
Unless specified otherwise in documentation all method calls and callbacks are typically handled on the main thread (UI thread).
"In the second example where you enter the infinite while loop, you completely tie up the UI thread so none of the life cycle methods can run anymore and the user can no longer interact with the application."
  The system calls onDestroy() after it has already called onPause() and onStop() in all situations except one
"For a while (~30 minutes since last use), it keeps track of the instance state Bundle for the activities on the task."
There is more than one situation in which onDestroy() is not called.
"Terminating the process due to low memory conditions may or may not result in onDestroy() being called, depending on the urgency of the need for system RAM."
"When you call getActivity().runOnUiThread(new Runnable() {}), this enqueues that Runnable to run on the UI thread after everything else that is already enqueued on the UI thread, which may include calls to onDestroy(), which would set mListener to null."
The best thing to do is to create a Handler and post the Runnable to it instead of calling runOnUiThread().
"onDetach() and onDestroy() reflect the component lifecycle, but not the object lifecycle."
"Additional Note: If you want to avoid duplicated code in your activities, you can implement the onDestroy in a superclass and let all activities extend from that."
Just keep a boolean flag alongside the static member which indicates if the current data has already been persisted.
After onDestroy gets called the activity object will be garbage collected at some point.
If the activity gets recreated it will be a new object.
Your dagger component will also be garbage collected then along with your activity.
"Now, if you want to make the GC run on an activity, calling finish() would achieve this."
"According to the documentation, the activity is destroyed and all its resources are queued for garbage collection, because a reference to this activity becomes inaccessible."
"To see, if that is indeed happening, add this to the onDestroy() method for your activity: Runtime.getRuntime().gc()."
"Now, to remove the previous activity from the stack, I will refrain from duplicating some great answers like these, StackOverflow Post_1 StackOverflow Post_2."
Now let me explain how onCreate will be called after onStop without onDestroy being called.
"After onStop if user navigates back to activity, it's onStart (before that onRestart will also be called) will be called."
Now it can be killed if system need more memory and your activity is consuming more memory than others (this is off-topic of this answer that which background is first to get killed).
"That's why in the question image (activity lifecycle), it is shown that onCreate will be called after onStop if App process is killed."
Whether you remove listeners in onDestroy() really depends on where you add them.
"You will indeed have to remove them by calling removeEventListener(), just like you add them."
Saving callbacks/listeners in weak references is not a good idea.
Using onDestroy or onDetach in the BottomSheetDialogFragment allows me to get the dismissal correctly
"If it's a bound service and you unbind in activity's onPause, onStop, onDestroy and the service is not bound from another place or started by context.startService it will die."
"When user presses back/home button, Activity can be destroyed anytime and thus you won't be able to receive the data using EventBus."
It is always recommended to unregister listeners in either onPause or onStop because the activity does not need those events when it is not in the foreground.
"Override onDestroy(), cancel the tasks, and set task references to null."
"(I'm not sure if setting references to null has any impact here; if you have further info, please comment and I'll update the answer accordingly)."
"A simple, 7-line onDestroy() snippet in the Usage section of the AsyncTask javadoc could have saved us all a lot of grief."
"It also has the advantage of not requiring mimimal code outside of the task class itself, touching one to three lifecycle methods, depending on needs."
Probably a good idea to do this in a service (ever running)!
"Warning: This only tells you when the MediaStore has been changed, it does not tellly anything specific about addition/deletion."
"Coming back to your example, calling unsubscribe() in onDestroy() of the Activity is fine and will save you from memory leaks."
That's been a deliberate decision (you can read more about it HERE).
Regarding your comment that problems occur when you call your test() method multiple times - I'd say your problem is somewhere else.
"On the other hand, you definitely should unsubscribe in onDestroy in order to prevent memory leaks."
You can restart it by using a BroadcasteReceiver which handles the broadcast sent from onDestroy() of your service.
OnPause happens at some point before onDestroy (depending on the execution case this may be any range of time) ergo yes to the above question.
If an object does not have a GC root it is eligible for GC.
"In general you should call cleanup() in the ""opposite"" method from where you create the adapter."
"At this point, if there are no other active components in the OS process, Android may decide to kill the OS process, or it may leave the OS process around for awhile."
When retain instance is true the fragment's onDestroy() method will not be called during orientation changes either so you can put your cancellation logic in there to know if the fragment is going away for good.
That way when the orientation of the device is changed the same Fragment will be reused and any ongoing background operations can be preserved.
A better answer to how isRemoving works based on reviewing source code
Not getting the error toast is the first milestone to setting this up right.
  The final call you receive before your activity is destroyed.
Don't forget to keep a reference to the subscription and unsubscribe when you no longer need it (eg.
"The issues you mention arise only when life-cycle of AsyncTask is not handled properly, mainly from lack of understanding of how they work."
"You can have a Fragment load latest news using an AsyncTask and when Fragment's onDestroy() is called, you cancel the task, since its no longer meaningful."
You can have a background Service run some continuous processing using  AsyncTasks on a separate ThreadPoolExecutor.
"Hence the answer to ""how long and AsyncTask should run"", entirely depends upon the usage context."
A data conscientious way would be to create a HashMap of ValueEventListeners and then in onStop or onDestroy you would remove those listeners.
"To keep things simple, you should use a single event listener to get the rooms."
"onDestroy() only gets called on an Activity as a result of a call to finish(), so mainly only when the user hits the BACK button."
"When the user hits the HOME button, the foreground Activity only goes through onPause() and onStop()."
"What this provides you is the ability to leverage the fact that a bound Service only lives as long as clients are bound to it, so you can monitor the onCreate() and onDestroy() methods of the Service to know when the current foreground task is not part of your application."
You might also find this article written by Dianne Hackborn to be interesting covering in more detail the Android architecture and how Google thinks it ought to be used.
In onDestroy you're trying to release a wakelock which you already released in onPause.
Your Fragment can be invisible but still not destroyed (paused).
       is called after {@link #onDestroy()}.
The NO_HISTORY flag just prevents this Activity from appearing in the task stack once the Activity is no longer visible.
"In your case, if you were to press HOME when Activity2 is shown, you would see that Android calls finish() and onDestroy() on that activity right away (which isn't the usual behaviour when a task is put into the background)."
Best practise is that if you open the Realm in onCreate you should close it again in onDestroy in all your activities as it means you reference count will reach 0 when all your activities have closed.
"@Scope annotations provide both compilation time validation, and on module provider methods, it makes Dagger2 create a scoped provider which will allow the creation of only one instance per scope within that particular component."
"It doesn't really do anything more than that, so if you need to explicitly unregister callbacks that are within your activity, then you should probably inject these dependencies within your activity, and manually unregister them yourself in onDestroy()."
"You will need to know where it crashed in order to set the try/catch blocks in the right place to, er, catch the crash and save the data or whatever you have in mind."
"Unfortunately neither Java destructor/finalize methods nor lifecycle methods such as onDestroy are anywhere near as robust as try/catch blocks so I'm afraid that is your only option, and how many of us deal with exception prevention."
"No-one would wittingly provide a user experience that crashes, much less with loss of their data."
"You should not rely on onDestroy() because it only gets called, when service is properly stopped (by calling stopService() or stopSelf() method)."
"As per the docs, don't rely on the onDestroy() method to persist your data."
"Problem is, their lifetime can outlast an Activity life by far, as they keep running in the background."
"I'm not sure how your app is supposed to work, but I can suggest a few things."
"There is an update to this answer as of March 2020 that supports API.15 through API.29, you can find it following to the original answer"
It's LifeCycle conscious by implementing LifecycleObserver to avoid memory leakage by doing some cleanup in onDestroy() method.
It supports from API 15 (Ice Cream Sandwich) through API 29 (Android Q)
"When such a change occurs, Android restarts the running Activity (onDestroy() is called, followed by onCreate())."
"  Some device configurations can change during runtime (such as screen orientation, keyboard availability, and language)."
The restart behavior is designed to help your application adapt to new configurations by automatically reloading your application with alternative resources that match the new device configuration.
"Remember to do any clean up necessary in onDestroy, which may or may not be called when your service gets killed by the system."
Unfortunately onDestroy() is not called when the app is crashed.
"To get a callback before the app is crashed, you should use an Exception Handler as mentioned here."
"Yes, it will stop, but you should also set subscription to null in onError too (or after error, you won't load items again)."
"If we do that, we get the exception during onDestroy()"
Hence we can't just simply destroy it before inflating the fragment.
"View does not have a callback (except finalize(), but I don't think that's what you're asking for)."
"Fragment has onDestroyView(), which may be more useful to you."
"View has onDetachedFromWindow() when it is removed from the screen, but this is not related to it being destroyed -- it could be attached again, which will call onAttachedToWindow()."
"Activity doesn't have an equivalent method, but you could use onDestroy() as long as you know it may never be called if the system decides to terminate your app unexpectedly."
The error message basically means that some component  created a binding to a Service and did not unbind from the service before the component was destroyed.
You can confirm this by adding the onDestroy() method to your MyIntentService with a Log command to show when it is called.
The Android runtime destroys an IntentService after onHandleIntent() completes and there are no more Intent requests queued.
"That means that in the code you posted for onHandleIntent(), your IntentService will be destroyed soon after the call to addLineItem() completes."
For some reason the service is not stopping when the app goes to background
An object can be garbage collected once all references traceable to it from GC root objects are gone.
Essentially the framework is done with the activity and is giving up any references it might have been holding to the activity and related resources.
"In general, if Android wants to kill your application because it has been in the background for too long (or because it wants to reclaim resources), Android will just simply kill the OS process hosting your app."
It will not call finish() or onDestroy() on any Activity or Service components.
"The behaviour of ""swipe from recent tasks list"" has changed over time and is different in different Android versions."
"You can programmatically create a BroadcastReceiver in your Service that listens for the ConnectivityManager.CONNECTIVITY_ACTION action, calling registerReceiver() when you want to start listening (say, in onCreate() or when you show the notification you eventually want to hide), then calling unregisterReceiver() when you want to stop listening (such as in onDestroy() or when you remove the notification)."
You can then retrieve the connectivity by using code such as
Try moving your broadcast receiver registration to onCreate and onDestroy instead.
"Taking a look at this question regarding onResume and onActivityResult, onActivityResult gets called before onResume, so by the time your fragment registers as a receiver it's too late."
"It seems quite unusual for Android to clean up an activity in the way you described, but if that was the case then your activity should still be restored."
"In the scenario you described the first activity should call onStop, but not onDestroy, then when you return from the second activity it should call onStart again."
"Now if I press back again FirstActivity will also be finished, causing onDestroy to be called."
The back button calls finish on SecondActivity so it's destroyed
You can see that this example has adhered to the lifecycle diagram exactly.
"The reason that it's not working for you is that you are using an IntentService, so calling stopService() will not cause onDestroy() to be called, presumably because it was already called after onHandleIntent() has completed."
There is no need to ever call stopService() on an IntentService see here.
"That way, when you call stopService(), it would call onDestroy() and unregister for location updates, as you expect."
It looks like you should probably just use Service instead of IntentService.
The only other change you would need to make would be to override onStartCommand() instead of onHandleIntent().
"For example, if you added it in onCreate remove it in onDestroy."
"Simple fix, but annoying that it seems to be completely undocumented."
All the answers seem correct so I'll go ahead and give a complete answer here.
"The this.sendBroadcast(broadcastIntent); in the onDestroy() method is the statement which asynchronously sends a broadcast with the action name ""restartservice""."
We'll be using this later as a trigger to restart our service.
"Note that in onDestroy() we are dedicatedly calling stopService(), so that our overridden method gets invoked."
"If this was not done, then the service would have ended automatically after app is killed without invoking our modified onDestroy() method in YourService.java"
"The above mentioned way will only work if the onDestroy() of the service is called, which might not be the case certain times, which I was unaware of."
You can set a listener on the onCreate() method on your activity
in onDestroy() to not receive anymore events when not needed/wanted and especially to not leak memory!
You can get any time if the user is logged in/out by calling
You can also set some hints according to the operations performed in the Child Activity by setResult() and this should be done before the ChildActivity call the finish() or onDestroy()
Note:  You must override the onActivityResult() of your parent Activity.
"In order to catch changes of discoverability of device (SCAN_MODE_NONE, SCAN_MODE_CONNECTABLE, SCAN_MODE_CONNECTABLE_DISCOVERABLE), create another BroadcastReceiver and register/unregister to your Activity as I mentioned above."
"Note that, you don't need to add any &lt;intent-filter&gt; or &lt;receiver&gt; to your AndroidManifest file, except you need to add Bluetooth permission of course."
"Having a BaseActivity as @jagmohan noted is possible, but if you don't want to have your own BaseActivity and want to use something as drop in."
"Don't forget to associate your mapview with the fragment lifecycle calling the events onCreate, onLowMemory, onPause, onResume and onDestroy (hope not missing any of them), and call to MapsInitializer.initialize(getContext()); as well"
Make sure you remove all callbacks to handler and set it to null in onDestroy
You should keep a reference to the handler and the runnable to cancel this when the Activity goes to pause and resume when it resumes.
"A suggestion to lower battery consumption, you could use Activity Detection to determine how often you need to determine position."
The main issue: you never call mLocationClient.connect() so the connection process never starts.
"Similarly, you should removeLocationUpdates() in onDestroy() and disconnect your mLocationClient."
…do not count on [onDestroy()] being called as a place for saving data … [see] either onPause() or onSaveInstanceState(Bundle).
When you application needs to save some persistent data you should always do it in onPause() method and rather than onStop().
Because if android OS kills your process then onStop() and onDestroy() methods are never called.
"However, the short answer to your question is that there is NO way to ensure that onDestroy() or onPause() gets called."
"What this means is that if the code in any of those methods is currently being executed, then the process won't be killed (or at least will be given a very high priority) till the code finishes executing."
"onPause(), though, does have a far greater probability of getting called, so you could look into that."
"The arrow in question is labeled ""Apps with higher priority need memory""."
"Hence, this diagram shows that onDestroy() is not called if the OS terminates the process because apps with higher priority need memory."
"onDestroy() is also called in other scenarios, such as finish(), the default behavior of the BACK button, the default behavior on a configuration change, etc."
"No, because the whole process is terminated ""if the app moves from onStop() to onCreate()""."
"For those things that you determine properly should be cleaned up in onDestroy(), do so."
"Specifically, anything that you're doing that may cause the user to regret having installed your app, such as requesting GPS fixes, should be considered for cleanup in onPause() or onStop()."
You are called with onDestroy() and can do your cleanup work
"Your process is terminated, in which case your cleanup work is no longer needed or possible"
The system calls this method as the first indication that the user is leaving your activity (though it does not always mean the activity is being destroyed).
onCreate() is to onDestroy() &amp;&amp; onStart() is to onStop() &amp;&amp; onResume() is to onPause() .. onStart() is called when onCreate() finishes its work.
if not its not called.. onResume() indicates the ui is about to be shown to the user -(An Activity's content is the screen the user sees).
In my code onDestroy method is called and toast message is displayed but service is not stopped
"You started that -- you need to stop that in onDestroy(), probably by calling cancel() on the Timer."
"IntentService needs to implement onHandleIntent() This method is invoked on the worker thread with a request to process Intent request and IntentService will be ""alive"" as long as it is processing a intent request (am not considering low memory and other corener cases here, but just thinking in terms of logic),"
"It turns out in Android that the app's ClassLoader goes away in onDestroy, not onPause, so a singleton implies you hold on to the memory even when the app is in the background."
The update to your question leaves an air of mystery around how you solved this.
You never call MessageApi.addListener() in your Wear activity so your MessageListener is never registered to receive messages.
It may make logic easier if you leave a GoogleApiClient open throughout the duration of your activity rather than try connecting/removeListener()/disconnect in your onDestroy().
The above code needs to be present also in onResume() method because each time orientation is changed onDestroy() is called and then onCreate() is called so onResume() needs to have this piece of code as well as onCreate().
"There is no guarantee that onDestroy will ever be called; once an activity has been moved to the background, it is fair game to be killed if system resources are required, even without calling onDestroy."
It is ok to mitigate this by catching the exception for the sake of avoiding crash.
"In other words, if you call finish() while creating the Activity in onCreate(), the system will invoke onDestroy() directly."
"Call bindService()/unbindService() in the onStart()/onStop() methods of both Activities (to get access to the Binder object, and be able to call methods on it)."
"a screen rotation) that is not handled explicitly will cause the activity to restart itself, and the service will be destroyed (since we're calling stopService() in onDestroy())."
"However, an important point still remains: in the event of a configuration change (e.g."
"To prevent this, you can check isChangingConfigurations() before actually stopping the service (since an onDestroy() callback occurring due to this reason means that although this particular instance of the Activity is being destroyed, it will be recreated afterwards."
Stopping the service in onDestroy() instead of onPause() saves you from having to check for isUserMovingToSecondActivity.
"It's not necessary to override onBackPressed(), since if the activity is destroyed the necessary lifecycle methods will be called (plus, it could be finished without pressing the back button, for example if calling finish() on it)."
Now the sound will not have enough time to be played before all memory and native resources used by the SoundPool object will be released.
Just call finish() - no need to do any of the onDestroy() stuff.
"Furthermore, any time you override onDestroy(), make sure to call super.onDestroy()!"
When onDestroy is called the reference to the Activity will soon be freed and be made available for CG.
The GC will see that the Activity is the only reference to the scoped graph and both will be marked for collection.
onDestroy() gets called on the UI thread (also called the main thread).
"Hence, until you return from onDestroy() no other framework method can get called - not only for this Service but for any other Service running in the same process."
Move register to onCreate and unregister to onDestroy of your MainActivity.
"Option #1: Don't use the binding pattern, but rather the command pattern (startService() in conjunction with stopService() or stopSelf())."
Calling recreate() essentially causes the Activity to go through a configuration change.
A configuration change causes both the Activity and its Fragments to be destroyed and recreated.
The fact that configuration changes cause fragments to be destroyed and created however does not mean that the FragmentManager will simply forget the fragments ever existed.
Point A: The service code is missing a key component
"In the code above, the service has an onCreate and onDestroy, which will be triggered when the service is created and destroyed."
"However, if a service is triggered and it is already running, then it will not go through onCreate."
"It's better not to use them and always get a reference from findViewByID, but you can just set all this fields to null in onDestroy() method."
For searching some leaks I used Memory Analysis perspective in Eclipse.
"Note that ComponentCallbacks was introduced in ICS, so if you're seeing problems on versions before ICS, then this is not the problem."
Create and initialise a Realm object inside onCreate and close it inside onDestroy pretty much like closing an SQLiteOpenHelper instance.
Construct the RecyclerView in code and supply the data it needs.
At the simplest your onCreate inside the Activity will look like this.
"After onDestroyView(), you can (and likely should) release all of your View references to allow them to be garbage collected."
Its view will be destroyed (as it is no longer visible) but the instance will remain around to be easily resumed when the user presses back to return to it (at which point onCreateView() will again be called).
"In many cases, it's not necessary, as if it's just happening during a configuration change, onDestroy() will immediately follow and the whole instance will be garbage collected."
"Essentially, I would say it is good practice to release any and all view references in onDestroyView(), and could save quite a bit of memory if your app has a large backstack."
"You cannot do fragment transactions after onSaveInstanceState has been called, so if your subscribe opens a DialogFragment then doing that before onDestroy but after onSaveInstanceState would crash your application."
"In all your activities/services, any where you make calls to gms api, check the objects you create and pass to gms; If they die, those objects are not valid any more."
Call stopService(intentOfYourService) at onPause() or onDestroy() and give the Intent you created at onCreate() (or elsewhere) to the parameteres.
"You must call Glide.with(getActivity()).pauseRequests() or Glide.get(getActivity()).clearMemory() in the method onDestroy() or onDestroyView(), just delete it."
If isFinishing() returned false in onPause it will also return false in onStop (and also in onDestroy).
"By default when you call finish in your activity it will automatically call onDestroy method of all the fragments that is attach to the activity thus destroying it, so no need to worry about destroying the fragment in onDestroy method of your activity."
The infinite loop problem comes when you disconnect the googleApiClient in onStop().
The problem is that you are trying to unregister more than once broadcast receiver.
Please follow to this question or siply remove unregister method from onStop() and onDestroy()
Remeber also that if you unregister broadcast at onPause you should register it once again in onResume()
"Likewise, if you'd like to move the creation to onCreate(...) then move the destruction and cleanup to onDestroy()."
"Additionally, onDestroy() is guaranteed to be called, even if the app is forceable closed by the OS."
"As for the actual code cleanup, I assume that periodicTask is a ScheduledFuture, but we all know about assumptions."
In Android M you have to get an extra permission for making overlays.
"Interstitial ads are fine for when you're staying in the app, but I guarantee when you try to spam them as they exit the app, their fingers will stray very quickly to the ""uninstall"" button."
Take a look at the Android documentation on exactly how to do this.
"When you press back button inside an Activity, it will call finish(), which will ""close"" it."
"When it happens, onDestroy() can (and usually will) be called."
  Perform any final cleanup before an activity is destroyed.
"In theory you can do whatever you want, if it works."
"When screen orientation changes, Android restarts the running Activity (onDestroy() is called, followed by onCreate())."
"To properly handle a restart, it is important that your activity restores its previous state through the normal Activity lifecycle, in which Android calls onSaveInstanceState() before it destroys your activity so that you can save data about the application state."
"When a dialog on an activity is set to visible but on orientation changes the activity itself is destroyed, then it causes leaked window error."
"Therefore,you need to dismiss dialog in activity's onStop or onDestroy method."
Yes you are right when you pressed the back buton the onPause() will get called and after is onDestroy() which will destroy the activity.
"Generally speaking, calling finish() will trigger a call to onDestroy() somewhere down the line, but it is not guaranteed."
"Your app process could be terminated between the call to finish() and the invocation of onDestroy(), or the battery could run out and so on."
"Therefore, as is also stated in the documentation, calling finish() will generally lead to onDestroy(), and you need not be calling it from within onDestroy()."
You can also use isFinishing() to determine if the Activity is already in the process of finishing.
It looks like the reason why the Remainder is growing is the growth of the number of Activity instances in the back stack (e.g.
Thanks to @NickT for pointing me in the right direction.
"You need to define your ""slide up"" animations from the linked question, and some new ""slide down"" animations that reverse the process."
onDestroy() is not called every time the activity is taken away
onCreate() is not called every time the activity is shown
"call super first, to init all object internals  before you code may use it, while on onPause(), onDestroy() first cleanup your stuff then call super to let superclass do its job too, otherwise your code may try to depend on stuff that is no longer available after super cleaning completed."
Lifecycle methods on all Android components are called on the main application thread.
  If that were to happen services will end when application exits
The most important part you are missing is the call to mUnityPlayer.quit() during onDestroy().
"Trying to create a new instance of UnityPlayer while the old one is still running will lead to crashes, hanging activities and endless suffering."
"Not a single method will execute after calling mUnityPlayer.quit(), not even the onDestroy() method will finish."
"The path to victory is to start your UnityActivity as a new process by adding the parameter android:process="":UnityKillsMe to your activty inside your AndroidManifest.xml."
"if you don't want to do it in onPause, you can unbind in onDestroy, that is fine."
"  When your client is destroyed, it will unbind from the service"
  2.When the onDestroy() method is currently called and I call
Try putting a breakpoint in this method and verify it gets hit.
"All the examples in the internet s...ks, with their UML diagrams absolutely unclear to beginners and plenty of code where only experienced one can understand why using this not that, one not another..."
"First of all, there is an open issue tracking this problem on the AOSP issue tracker."
You can see that neither onPause() nor onDestroy() were called and thus my application did no explicit cleanup for the NSD service.
NsdService is detecting when the AsyncChannel to the client is terminated and is cleaning it up properly.
"There is no way to guarantee onDestroy() is called, a deeper explanation here."
For 5.x NsdService shuts down the NSD service when your app disconnects.
Installation via Android Studio killing the running application without it being called.
"Suppose, you called the finish() method to finish current activity as below then onDestroy() will be called."
You can get more information about onDestroy() method from Developer site.
The core functionality of all 3 methods are same and that's why they are having similar names.
Remove super.onDestroy() from onPause() method and add super.onPause() as below...
"Default behavior is that when you press hardware ""back"" button, current activity will be removed from the backstack and activity ""destroy"" sequence will be initiated."
What my previous investigations show is that victim's onDestroy() will be called only when new activity is done loading and is idle.
From that moment you should not rely on the fact that it might be somewhere around - it is all up to Android to decide when does it actually kill this activity.
onDestroy functionality is to destroy all the used variables and consumed memory.
All those will be flagged as a Dummy data to enable the garbage collector to remove them from the memory whenever it is needed.
Calling the Fragment again after calling onDestroy will pass through the lifecycle again from the beginning through onCreate and all the variables and local object will be re-initialized again.
Just don't forget to cancel the timer on Service's onDestroy method otherwise you'll leak the Service instance.
"When it is displayed again to the user, it must be completely restarted and restored to its previous state."
"Suppose there is an activity A, from which you launch activity B."
"Whenever you push an activity to the stack, onCreate is called, and if you press back button, onDestroy is called, which means that the activity is flushed away."
"If, while in activity B, you hit the back button, you are popping activity B off the stack and B will not be in the activity stack any longer."
"You can inflate a view from a layout resource and add it to the WindowManager as a TYPE_SYSTEM_ERROR, so will be on top of everything."
To avoid the notification bar of showing I added the flags FLAG_NOT_FOCUSABLE | FLAG_NOT_TOUCH_MODAL | FLAG_LAYOUT_IN_SCREEN to consume all pointer events.
"DeadObjectException - The object you are calling has died, because its hosting process no longer exists."
  Override your service's onDestroy() method and watch what event flow
Inside your onStop() or onPause()andonDestroy() make sure you dismiss your view(dismiss() if it's a dialog) or remove it(remove()if added using window Manager).
Add the dismiss or remove functions inside your on unload function as you mentioned that on pressing back button you get this error.On exiting an app its onUnload() method gets called.
Well managed to solve this only by switching the position of the super call in the onDestroy() function.
It seems I needed to first destroy or unassign the fragment from its parent to make it work.
"where mFragments.dispatchDestroy() will finally call fragments onDestroy(), if you digg into the source."
"First: In your onPictureTaken call back you are calling the finish() method, wich in turn signals that the activity should be destroyed, and calls the onDestroy() method, wich in turn releases your camera."
"However your MainActivity.java is not destroyed (not really sure why, but through logCat, I found that the onCreate() is only being called once, so I assumed the activity is not destroyed."
"First of all, it is really very bad pattern to run service forcefully against the user's willingness."
"Anyways, you can restart it by using a BroadcastReceiver which handles the broadcast sent from onDestroy() of your service."
"Whenever a service is killed, its onDestroy method is always called."
Its better to use a BroadcastReceiver to start your service when it is killed.
onCreate is not called when a new activity is created.
"After this, if you press Back into your activity B, B will be paused(onPause()), stopped (onStop()) and destroyed(onDestroy()), and activity A will be restored from back stack, started (onStart()) and resumed(onResume())."
"For example, if you have activity A and starts activity B from it, then activity A will be paused (onPause()) and then stopped (onStop()) and moved to back stack."
"As you can see, system will not call onCreate() for A again."
"For example, you should unregister listeners for GPS, sensors, etc in onStop() and register again in onStart()."
"In the case of a Camera, you do not want to hold onto it when you are not in the foreground, as other apps cannot access it while you have it, so I would go for the onResume()/onPause() pairing."
"Even if onDestroy() is called on the activity, the process itself can be running indefinitely for caching purposes."
"Now, as far as I know, Dalvik doesn't unload classes so the lifetime of your statics is really bound to the lifetime of the process."
"When you relaunch the app, this cached copy is brought back."
"In my case, I followed the tutorial at Android Developers, which uses a ServiceConnection."
"In the example code, they call unbindService() but never stopService()."
"When I moved things around so that I'm calling unbindService() first and stopService() after that, my onDestroy() gets called immediately."
onDestroy is guaranteed to be called when you explicitly call finish().
"On the contrary, when you are minimizing your app by pressing Home key onDestroy may well not be called right now."
For debugging purposes you can enable Settings|Developer Options|Don't save Activities.
The thread will stop when continueSocket is set to false.
Problem is that LocalServerSocket.accept() blocks until there's something to do.
"The only point where they might have diverged is when the system kills the process to clear memory, but there are no callbacks or interaction with the app at that point."
You can put it in a fragment with setRetainInstanceState(true) set.
Place your code in the onDestroy() method of the fragment.
"You definitely should not be calling onPause and onDestroy manually :) This is something Android does, not you."
Call the checkActivity() in onCreate of service and dont forgot to remove the handler.removeCallbacks(activityRunnable); callbacks in onDestroy
start the service in LauncherActivity onCreate and stop the service in LauncherActivity onDestroy
Note: Dont forgot to add the permission in your manifest
i found this simple trick to solve this problem without using AlarmManager.
"When the Activity is restarted because of a orientation change, the Android Framework recreates and adds the Fragment automatically for you."
onCreate() and onDestroy() are not called (Because those event do not happen)
"Notice you call flush() before calling super.onDestroy();, otherwise the activity lifecycle will continue and your call might never be on time, this way the destroy process will at least start after the flush."
You code looks perfectly fine if you want to get the location in the foreground.
hence as and when the current app is going to background and the onDestroy is called by system then the code fails to update the location in the background.
more over when you launch the application again it will start the service and very first time get the older location which was cached.
"First, this answer assumes that you are referring to Android's Activity class and its finish() method and onDestroy() lifecycle method."
"Your process could be terminated in between finish() and onDestroy(), for reasons independent of whatever is triggering the call to finish()"
A device manufacturer or ROM modder could introduce some screwy change that would break the connection between finish() and onDestroy()
The battery could go dead in between finish() and onDestroy()
"Generally speaking, finish() will eventually result in onDestroy() being called."
"Because onDestroy() is not guaranteed to be called (generally, only if you finish() your activity) and because after onStop(), your activity is not guaranteed to remain."
It might be destroyed for any number of reasons once it is not the foreground activity.
AsyncTask is a background task it will continue to run even if the app is closed and onDestroy() is called.
"The problem would be when the task enters onPostExecute() and tries to update any views associated with the activity it is bound to, as that activity no longer exists."
"Yes, I would put the DB operations in the doInBackground() method, as that runs in the background on a separate thread, and doesn't require a reference to the app activity."
"When you press home - onPause and onStop of your Activity is being called, so at this time you have to do all savings and cleanup, because Android platform doesn't further guarantee that onDestroy or any other lifecycle method would be invoked, so the process could be killed without any notification."
"Even if I think you already read it because you already study the activity lifecycle, you can see in the first figure that the onDestroy() is called after the onStop() and this call is totally managed by the system : you shouldn't expect any behavior."
"The system will decide itself WHEN to call this method, and sometimes, this method will never be called (see here : http://developer.android.com/reference/android/app/Activity.html)."
"When system needs memory, your activity will pass in onStop() and nothing more."
"You will next receive either onRestart(), onDestroy(), or nothing, depending on later user activity."
  Called when you are no longer visible to the user.
Before dismissing check like this in onDestroy() or onStop() method..You are simple dismissing  not checking whether it is showing or not
onDestroy() Perform any final cleanup before an activity is destroyed.
You are overwriting the value for the key value every iteration of the for loop in your onDestroy.
"You'll have to store each value with a unique key, each corresponding to a unique button, then retrieve each individually in your onCreate."
onDestroy() occurs when the Activity finishes or is being destroyed by the system.
"Given that when your phone powers off, all activities are shut down and therefore the onDestroy() method is called at that moment when the Phone shuts all of the applications and its process down."
Application A might call finish() once the Intent is sent to start your Activity.
You can also register it within your existing class file.
"here, you dont need any broadcast registration in manifest except activity registration"
You can't finish activity after showing interstitial because it won't show up.
I'm surprised that there is still no proper and complete answer for this question so I will put my code which is working properly.
Here is a log lifecycle of each fragment in ViewPager which have 4 fragment and offscreenPageLimit = 1 (default value)
Conclusion: FragmentStatePagerAdapter call onDestroy when the Fragment is overcome offscreenPageLimit while FragmentPagerAdapter not.
Note: I think we should use FragmentStatePagerAdapter for a ViewPager which have a lot of page because it will good for performance.
"If in this example, we set offscreenPageLimit=4, there is no different between using FragmentStatePagerAdapter or FragmentPagerAdapter because Fragment never call onDestroyView and onDestroy when we change tab"
If we set offscreenPageLimit &gt; 1 it will not destroy.
Swiping the app from the recent tasks list actually kills the operating system process that hosts the app.
"As you call the doBindService() in the onCreate(), you should add the do UnbindService() in onDestroy()."
"The activity is not being ""recreated"", it is only being ""restarted""."
"If the activity was being recreated due to a config change, you would also see onDestroy() and onCreate() being called again."
Make sure to stop threads manually if you don't want them anymore.
"Basically, there's never a guarantee that onDestroy() will be called, and in some cases processes such as your app will be killed directly, bypassing the method call anyway."
The WeakReference class basically just prevents the JRE to increase the reference counter for the given instance.
"You have to code the desired behavior with the known mechanisms (onCreate/onDestroy, onSave/RestoreInstanceState)."
The orientation change itself will not automatically restart the AsyncTask.
I'm assuming you're not retaining the instance of the AsyncTask currently and calling cancel on it in your fragment/activity's onDestroy.
"Either add that, or add a boolean flag stating if the app is visible or not (API 17 introduced Activity.isDestroyed(), if you're using API level >= 17 simply use that)."
"You're probably getting the exception because somewhere in the activity lifecycle, you called mHelper.dispose(), then tried to use that same disposed instance later on."
My recommendation is to only dispose of mHelper in onDestroy() and recreate it in onCreate().
"However, you will run into another problem with IabHelper and device rotation."
"Later, you call mHelper.launchPurchaseFlow(...) and the IAB popup dialog appears floating above your activity."
"The IAB dialog is still showing, you press the purchase button, and the purchase completes."
It will purely depend on the system condition at that time.
  There are situations where the system will simply kill the activity's
"However, if there is no more memory available, the system will call onDestroy(), so it can free up memory."
"*onStop() is called when you press the Home button, Back-button, or launch another activity that entirely covers the initial one."
finish() will indicate that you're done with the Activity and will subsequently trigger a call onDestroy() and remove it from your back stack.
Removing these calls should cause back navigation to behave how you expect.
Its not necessary that it would be called when the activity is finishing.
Note: do not count on this method being called as a place for saving data!
"onDestroy() is called only when system is low on resources(memory, cpu time and so on) and makes a decision to kill your activity/application or when somebody calls finish() on your activity."
- there is no way to do something because the entire application process (with your package name) is simply killed by something like Process.killProcess (int pid) without any callbacks.
As a workaround you should create some Base Activity and in its OnPause() do the stuff you want and then make all other activities in your application inherit from it.
There is no callback made to inform you that this has happened.
"That is documented in the documentation: ""There are situations where the system will simply kill the activity's hosting process without calling this method (or any others) in it ..."""
Send this kill message to the handler from your activity onDestroy()
Thank you to @Sheldon for pointing me in the right direction regarding setRetainInstance(true) on a 'headless' fragment.
"(onDestroy() is not called)  When MainActivity is re-created by Android, our headless fragment gets re-attached to it automatically."
"Now, when our MainActivity extends FragmentActivity is destroyed on an orientation change, the headless fragment gets stopped, and even detached, but not destroyed!"
"At this time, in our headless fragment, onCreate() is NOT called."
"We can disconnect from GameHelper in onDestroy() because this will never get called, except when the Application finishes (which, at that time, it's ok to kill our connection)."
Note: I think GameHeaderFragment.java should probably be broken up into an Abstract class and a game-specific class which inherits from it (but I didn't do that here).
Partial Wake Lock is all you need to access accelerometer readings while the screen is off.
You can override onDestroy() in the Activity which will be the last one closed in your app and check if it's finishing.
In this case your code will not be invoked on a device rotation.
"Hence, a more accurate statement is that the lifecycle methods on Service -- onCreate(), onStartCommand(), onBind(), and onDestroy() -- are called on the main application thread."
  Can someone explain this statement from android reference for Service
"First, your BroadcastReceiver is going away nanoseconds after the end of onDestroy(), making it useless."
Please register your BroadcastReceiver in the manifest with a &lt;receiver&gt; element.
  Methods you override that are part of component destruction
Put a if(mp != null) { } around mp.stop(); in the onDestroy() method.
It is possible that you try to stop the MediaPlayer when it hasn't been initialised yet.
"Yes, the problem occurs when using screen ""Landscape"" only, because the screen changes to ""portrait"" internally."
"To prevent this, call onDestroy() in case screen goes ON or OFF."
so you can write a function in your onDestroy which gets the CameraPosition from your map and store it in your SharedPreferences.
In your onCreate() you recreate your CameraPosition from the SharedPreferences (after your map is instanciated).
  Note: do not count on this method being called as a place for saving data!
"You might be about to comment on this and say, hey Chris, if I register in onResume() and and events are fired before I hit this method I won't receive the events!"
Make sure that your second activity is not finished before calling
"you should call setResult before onPause, onStop, onDestroy, finish ... etc"
"Yes , onPause() will be called when an activity is no longer running."
Suppose an activity is closed then the sequence of events will be onPause() -> onStop() -> onDestroy().
"Even if your activity slips into the background when another activity starts or when the screen switches off, onPause() is always called even if the other two methods aren't called."
Yes it is possible inside your LauncherActivity You can override onDestroy this method will be called on application exit.
onDestroy: The final call you receive before your activity is destroyed.
now if you Press Back Button then --> onPause --> onStop --> onDestroy.
now again open Activity its go to --> onRestart --> onStart --> onResumme(activity is running again).
"Make a dummy application, override onCreate, onStart, onResume, onPause, onDestroy, onRestart put Log.d(""MYAPP"", ""onXXX called"") in there and see for yourself what and in which order gets called."
You have probably somewhere a reference which you forgot to free.
There's no guarantee that Android will really delete an object from memory if it's not required to do so.
"In other words, Activity objects can stay in memory even after onDestroy() has been called (if there's enough memory available)."
"On the other hand, there's no guarantee that onDestroy() will be called if there's not enough memory; quite to the contrary, Android is allowed to kill your whole process after calling onPause() on your current Activity (depending on the Android version)."
In activity's onDestroy() just call a method on MyHandler that sets the reference to the Activity to null.
The Handler can just contain a reference to the Activity.
"Ok, since this has proven to be an especially difficult question, I thought I'd post my solution here in case anyone ever hits anything similar."
"If it fires, it shuts the service down cleanly, which in turn triggers a clean up of the managed state in the service's onDestroy()."
"The shutdown timer is scheduled within onUnbind() and gets cancelled in onStartCommand(), onBind(), onRebind()."
super.onDestroy() must be the first call of the onDestroy method if you override it.
Create ExecutorService in Service => onCreate() and shutdown it properly in onDestroy()
My cycle above needs to perform those 8 steps in that exact order so IntentService would be the ideal solution.
"Stop that work in onDestroy() of your service, triggered by a stopService() call from your activity."
"Start that work in onStartCommand() of the service, triggered by a startService() call from your activity."
"In between startService() and stopService(), your service will run... for a while, at least."
"Your activity stuff would only be lost when onDestroy is called, which happens when you finish it, or when it's destroyed by the system (i.e."
"My approach is slightly different and perhaps, a little lengthy."
"Finally, in the onDestroy() (I use this, but I suspect the onPause() could work too."
"Never done it in the onPause() in all honesty), check the status of the boolean blMyAsyncTask"
"If I have more Asycntasks added to the Activity, I can add another check in the onDestroy()."
Well I did a lot of digging and found that  addGpsStatusListener(gpsStatusListener) was deprecated in API 24.
"For example, if you are using this a Fragment, register it in the onResume and unregister in the onDestroy."
Don't forget to register and unregister this efficiently in Fragment/Activity Lifecycle as well.
"First to update map in 15 sec call AsynchTask in timer like this,"
"Now in YourAsynchTask() call webservice in doInBackground, get marker data from webservice fill the ArrayList of marker objects, and pass the ArrayList of marker objects to the method where you display the markers."
The best way to understand would be to have all the LifeCycle methods overridden in your activity and placing a breakpoint(if checking in emulator) or a Log in each one of them.
"If the OS destroys the activity in the meantime, onDestroy() gets called."
"Just as an spoiler, onCreate() gets called first, then if you paused the activity by either going to home screen or by launching another activity, onPause() gets called."
"Edit: I forgot about onStop(), it gets called before onDestroy()."
Do the exercise I mentioned and you'll be having a better understanding.
"When an activity is not on foreground it gets to onStop and then the system could terminate it, to release resources, by onDestroy method!"
"Additionally, finish() only calls onDestroy(), which is not a deconstructor, as explained here."
"Your variable is in the Application class, which follows a Singleton model, and hence your value will persist until the entire app process is killed."
"The below chart illustrates the Fragment lifecycle, as you can see, using getActivity() from onCreate() to onDestroy() should be a valid call."
"In the activity, for example in onDestroy() you can trigger a command to notify the service that the ResultReceiver is invalid and it should be removed."
(You can defer this to onStop if you are targeting only Honeycomb and later.)
You can handle this case separately if you must (it depends) through the onRetainNonConfigurationInstance() callback and the getLastNonConfigurationInstance() method.
"Most likely, some of your code is located in the wrong callback, such that in the third scenario, something does not get initialized/attached/..."
"After some testing and reviewing FragmentManager.moveToState, I believe that when the Fragment is being handled by a FragmentPagerAdapter, it is unavoidable that a Fragment which was previously coalesced into savedState (as part of the process of stopping the app before you kill the process from the DDMS tab in eclipse), must first be ""created"" (in the terminology of FragmentManager) before it can be destroyed."
"The visual experience is that this occurs, but it seems like the FragmentManager takes it on itsself to continue the lifecycle for previously existing Fragments, albiet with some short cuts."
"The best way to handle this appears to be to address the secondary issues (in this case, your NPE) caused by this startup."
"You can try unregistering in onDestroy() instead, but the surest way to avoid leaking is onPause()."
"Alternatively, to make the button respond no matter what, consider making a Service, and having that register your receiver."
"It seems that the OS thinks your service is in the background as soon as the user leaves your activity, despite it being a 'foreground' service."
"When the music stops, either by user interaction or when the song ends, be sure to remove notification and release wake lock."
"The point is that after the onStop(), onDestroy() was called subsequently."
The problem with using onStop is that you have no guarantees on when it will be called since the only sure thing is that it will be called before onDestroy.
Generally is recommended to close any datasources and cursors in Activity's life-cycle method either onStop() or onDestroy() method.
"While you are working / accessing to data in Cursor, it needs to be opened!"
In your case call cancel() to Toast object to cancel it within onDestroy() method.
"It is best to call commit() either right after you've made the changes, or in the onPause() method."
"The Android lifecycle can be pretty confusing, and so far I've found only one way that lets you have a decent idea of what's going on around you."
"You design your app in a way that you're always assuming you can be killed at any instant without callbacks like onDestroy() being called, because there is no guarantee that they will be called at all."
Call this method in onDestroy() and onstop() of your app.
Having test my app with 2 different implementations of AdMob I found that implementing it via java code and not XML is match lighter for the app.
also do not forget to call adView.destroy() onDestroy() activity or when you do not want it any more!
The above way is mentioned here with many useful memory releases!
I've spend a half day resolving this trouble and only found a workaround.
Normally services are stopped in onPause or onDestroy of your last activity.
The reason I am not doing it in onCreate() and onDestroy() is once user go to other activity onCreate() of new activity will be called first then onDestroy() of old activity so if I perform any operation(ex:- search in my list or changing the status of user etc) on places other then onCreate() it will crash the app with reason database already closed.
In this way database is always open for each activity.
"Note: You have to open and close the connection, even if you are using SQLiteHelper class."
You can call isChangingConfigurations() in onDestroy() on API Level 11 and above.
"You can refer to this post, How to distinguish if activity is changing configurations."
There is no way of accessing the Intent in onDestroy.
"You have to signal the service some other way (Binder, Shared Preferences, Local Broadcast, global data, or Messenger)."
You activity could be destroyed upon pressing the home button if the system is constrained and has determined it needs to free some resources.
"Additionally, do note that the system can kill your program without calling onDestroy() after onStop() has been called."
You can distinguish between these two scenarios with the isFinishing() method.
"Therefore, any cleanup/data persistence code should be in either onPause() or onStop()."
You have removed the call to super.onDestroy in your onDestroy() of Your Activity.
Just change that Code as below and give a try.
"The problems with restoring an embedded CordovaWebView were because the interactions with the CordovaWebView in onPause(), onResume(), onCreate() and onDestroy() did not occur correctly."
"When starting to fix, restoreState() occurred twice which caused further problems."
"I'm not sure about this one, as I haven't specifically tried it."
"  But I'm wondering if it's possible for a service to ""go away"" without onDestroy() being called, while the observers it created would live on and continue to receive changes."
"Other than the unhandled-exception possibility I mention above, I am reasonably certain that if the process will be terminated in the conditions where onDestroy() is not called."
You can save a reference to the Toast and cancel it in onDestroy().
Or just not interact with the UI in such a short lived service.
There are situations where the OS will kill your application without calling your onDestroy.
"Just a word of advice, of course, as it does not directly apply to your scenario."
"If system.exit(0) was not called because the app is already killed, I'd say you're OK. ;-)"
-- there's no other component (Service or a ContentProvider) running in the app that the OS is aware of.
Here's something I learned the hard way - Google's Android docs are not exactly accurate about everything!
"For example, In this case, the contract says that if you follow the rules, implementing the required lifecycle callbacks when they are needed, then it will work, and you do not need to know exactly under what circumstances onStop(), onSaveInstanceState(), onPause(),onDestroy() etc are called."
The best way I have found to deal with this is to find out the contract that Google promises the developers and stick to it.
"In other words, If you do what is needed to be done when your app is paused by implementing onPause() , Then you don't need to know exactly when your activity will be paused."
"A workaround that I found is to put a startActivity() call into onDestroy() (before super.onDestroy()) that starts a dummy instance of the Activity, just to keep the app alive."
The Android system won't garbage collect the app thread because there is still an Activity running within it (the new dummy Activity).
"When your force stop an app, exactly that happens - It is Force Stopped."
There is absolutely no guarantee that onDestroy() will be called.
"The entire process is killed, and none of the running components (Activities, Services etc) are given any warning."
"Move any application critical code into onPause(), which is called under most circumstances."
My guess is (because it's a common mistake) that you are registering the listener in onResume() and unregister it in onPause().
"If that's what's happening, changing your code to register during onCreate() and unregister during onDestroy() will fix the problem."
One possible cause of this exception is that the MediaController could still be querying the MediaPlayer object for its current position even as you're finishing the Activity and releasing the MediaPlayer object.
In my case I haven't had any NullPointerException in onResume() or onDestroy().
you can use onDestroy() or onBackPressed() callbacks on your main/launcher activity
Between public and protected there's no difference in the functionality.
The only difference is that with public you will be able to call onDestroy() on an instance of the activity from any class.
With protected you can call only in the same class or subclasses in the same package.
With onDestroy() I don't see a lot of sense in making it public.
"When we add the Fragment in the back stack, is called in sequence the methods onPause(), onStop() and after the onDestroyView()."
"In this state, the fragment clean up the resources associated with its view and ""stay"" there waiting to be called again."
"In the other side, when we use detach() to remove or replace the fragment, is called in sequence all same methods cited first (onPause(), onStop(), onDestroyView()) adding this two methods: onDestroy(), to do final cleanup of the fragment's state and onDetach(), to detach the fragment to being no longer associated with its activity."
"Basically, behind the scenes, they don't have the same behavior: using the addToBackStack() the fragments remain instantiated and detach(), don't."
a bundle passed from onSaveInstanceState() is received as a parameter in onCreateView().
"On the other hand, you should never relie on the onDestroy method of the Application class, as it is not always called."
"There may be some use cases where you need to do stuff before even your first activity is launched, then do it in the onCreate method of the application class."
When user will pick up call then CALL_STATE_OFFHOOK will get called.There you can write the code to pause playback.
There is generally no guarantee that the onDestroy() method will be called at all.
"To release Cursors etc, i recommend to use onPause() or onDestroy() methods of Activity but also it depends on Context of method."
Here is a sketch of a BroadcastReceiver that works for me.
"Keep a reference to your task, and in the onDestroy and onConfigurationChanges methods, cancel the task.."
"For this, you can use a BroadcastReceiver in your Activity."
"In your onDestroy() of the activity, make sure you unregister the broadcastReceiver."
"In your main activity, declare a static boolean flag that you set to true when you run the start-up code."
"In onCreate, run the start-up code only if the flag is false."
To stop it you should be using Activity lifecycle  methods such as onStop() or onDestroy() to cancel() the AsyncTask.
To not reinvent the wheel you should probably use some libraries which do exact that (load remote images) like Ignition.
An Activity then registers for updates in onResume() and unregisters in onDestroy().
"A Fragment is a useful approach, I think, when you want to tie some UI business logic to a particular View (or group of)."
"Furthermore, I had to extend and modify FragmentPagerAdatper to make sure that the Fragments go through their onDestroy() properly and are removed from the FragmentManager when the ViewPager was removed."
"Fragments enable a very modular way of constructing UIs for various screen sizes and orientations, and are excellent in how they allow you to encapsulate business logic and lifecycles for individual UI elements."
The problem is that I'm cancelling the AsyncTask in the activity's onDestroy.
close your database on onStop() or onDestroy() method of your activity.
"I've had no problems since, I just use the service on a bidden state."
"onDestroy gets called just before you completely finish the activity by calling Activity.Finish(), or when the system has to remove it from the memory to save space."
"onStop gets called just before the user exits the activity , or when another activity starts pushing this one in the background."
"For more info about the application lifecycle , see here."
You should never call methods of the Activity life cycle by yourself!
I'm wondering if it is necessary to call through the super class onCreate and onDestroy methods when overriding these methods in my implementation as it happens when you override such methods in an Activity.
"Even if Activity1 is not destroyed (onDestroy() is not called, only onPause()) the flag will be invalid."
Interestingly it does not matter whether you call finish() on Activity1.
"For lifecycle methods with clear ""destruction"" semantics (e.g., onPause(), onStop(), onDestroy()), chain to the superclass last, after any of your work"
"For lifecycle methods with clear ""creation"" semantics (e.g., onCreate(), onStart(), onResume()), chain to the superclass first"
"For everything else, it hopefully does not matter unless documented otherwise"
"Hence, it will keep running until the process is terminated."
Stopping the service won't make it stop if it has bound connections.
There is an ORMLite example Android project which demonstrates this called HelloAndroidNoBase.
You'll need to have this sort of code in each one of your Activity or other classes that uses the database.
You need to register MyReceiver in onCreate() and don't unregister it until onDestroy().
in onDestroy() before you call the super or call destroy() on your webView object.
It's not that it isn't reliably called... it's just that it isn't the only way the Activity can be killed.
The Android system might trash your entire process without giving the ActivityManager the chance to call onDestroy() if your device begins to lack memory resources.
"For this reason, you shouldn't ever rely on onDestroy() being called, and you should always save persistent state in onPause."
"Analyzing this diagram, one can conclude that  onDestroy() never automatically leads to App process killed."
"In the onDestroy() method of the Activity, set a flag to indicate that the Activity was destroyed."
"Additionally, in the AsyncTask add a WeakReference to the Activity instead of a normal reference."
In onDestroy() method of the Activity shutdown the TTS service using
"You should call myTTS.shutdown() when you are done with it, for example in your onDestroy."
"Hence when the user launches Task 1 again, the ActivityB is shown rather than ActivityC."
"The PagerAdapter should call the destroyItem method not only when it surpasses the offLimitScreenPageLimit but also when a screen rotation occurs, but it doesn't, so it has to be forced to do so... to achieve it, you just have to set to null the adapter on the onStop or onDestroy method of the activity."
Make sure you save persistent state in onPause rather than onStop and onDestroy.
You should never rely on either onStop or onDestroy to be called.
while awaking destroy the previous running service by calling it onDestroy() method.
Create an alarm  that will awake a Service on Specific Timer Interval ( in your case 30-120 seconds ).
Your application will not receive any additional callbacks if the process it terminated by external means (i.e.
There is no guarantee that onStop or onDestroy will be called.
"In situations when memory is severely lacking, the partially visible and out-of-focus Activity may be destroyed to reclaim resources."
"However, there is no guarantee that either of the two mentioned lifecycle methods will be called before doing so."
"Per the Activity Lifecycle, your app is killable any time after onPause() on most devices (any device with less than Android 3.0 / API level 12), and any time after onStop() on any device."
"Note that as @VipalShah pointed out, you were using the wrong signature for onDestroy()."
The id is an integer you can assign to the notification and notification is a Notification object (you can read about it more here: http://developer.android.com/guide/topics/ui/notifiers/notifications.html).
All I need to do is call to GCMRegistrar.onDestroy(this) in the onDestroy() method in the same Context I'm calling GCMRegistrar.register()
Dismiss the dialog in your onFinish or onDestroy of the launching activity.
You probably should do it in onPause() instead of onDestroy() beause usually switching to a new Activity won't finish the current one unless you explicitly do it.
"Added this answer very late, but I thought it would make things clearer."
"ALL lifecycle methods are called on config change, including onCreate() and onDestroy()."
"All lifecycle methods are called on config change, APART FROM onCreate() and onDestroy()."
Retaining an instance will not work when added to the backstack.
"In short, no, onDestroy() is not called, and you can't do this."
onDestroy() does not appear to be called in this scenario.
"(And according to this post, onDestroy() is really unreliable and won't be called often, if at all, on phones, whereas it may be called on an emulator - so be aware of that)."
Static variables are immune against automatic memory manager and you should to set them to null in onDestroy method(Android).
They belong a class sure and exactly it works as meant @Jigar Joshi.
"Although some static analysis tools frown on this, in the onDestroy() methods of your Activity you can null all your local variables (except primitives), it helps to nudge the garbage collector sometimes and can make for an easier to analyse heap dump in MAT."
"Make sure you haven't passed a Context anywhere and held a reference to it, this is a classic android memory leak and it's really easy to do!"
"  interact with the user, or onDestroy() if this activity is going away."
  Followed by either onRestart() if this activity is coming back to
"However, assuming you know for sure that you're not interrupting threads or other background operations and you use this call in onDestroy() - I see no reason why you shouldn't use it."
"Yes, letting the OS manage its own memory is the best practice for both you and the user using your application (faster to open again, less chances for force closes, etc...)."
"Especially when it's an API call and not a workaround, and Google didn't mention it's better not to use it in the API documentation."
  onDestroy() is The final call you receive before your activity is destroyed.
"When using FragmentPagerAdapter or FragmentStatePagerAdapter, it is best to deal solely with getItem() and not touch instantiateItem() at all."
"A fragment can add a listener or an observer to another object in onCreate(), and then remove it in onDestroy(), thus managing the updates itself."
"That's the advantage of having a fragment, after all - it is its own controller."
You don't have to put all the update code inside getItem() like you do in an adapter for a ListView or other AdapterView types.
"When calling finish() on an activity,  the method onDestroy() is executed."
It's just a method that's called based on a certain state.
"The process will not be doing anything and if memory needs to be reclaimed, the process will be killed"
"In addition to @rommex answer above, I have also noticed that finish() does queue the destruction of the Activity and that it depends on Activity priority."
"If I call finish() after onPause(), I see onStop(), and onDestroy() immediately called."
"If I call finish() after onStop(), I don't see onDestroy() until 5 minutes later."
"From my observation, it looks like finish is queued up and when I looked at the adb shell dumpsys activity activities it was set to finishing=true, but since it is no longer in the foreground, it wasn't prioritized for destruction."
"In summary, onDestroy() is never guaranteed to be called, but even in the case it is called, it could be delayed."
@user3282164 According to the Activity life-cycle it should go through onPause() -> onStop() -> onDestroy() upon calling finish().
The diagram does not show any straight path from [Activity Running] to [onDestroy()] caused by the system.
"onDestroy() is meant for final cleanup - freeing up resources that you can on your own,closing open connections,readers,writers,etc."
"on the other hand, finish() just lets the system know that the programmer wants the current Activity to be finished."
it isn't necessary that only a call to finish() triggers a call to onDestroy().
"In the AccountsListFragment, I now create my database adapter (AccountsDatabaseAdapter) in the onCreate() method and close it in the onDestroy() method and it now works."
Previously I was creating my adapter in the onActivityCreated() and closing in onDestroyView().
"Note that I am not referring to the ListAdapter, but rather to my database interfacing AccountsDbAdapter."
"Which would mean that when I close one in onDestroyView(), the other is also closed and the cursor data set becomes invalid which results in an empty list view."
"If I were to guess, I would say that the same database object is returned for both database adapters (the database is cached)."
The loader does not reload because it thinks the data has not changed.
"You put your infinite loop in a background thread, using something (e.g., an AtomicBoolean) to tell that thread to stop when needed (e.g., onDestroy())."
"  I'm also realizing this service should be started on a seperate thread from UI so as to avoid the ""App is not responding..."" issue but that's sort of another topic."
"Once you determine where and how to call stopService(), then all you need to do is get onDestroy() of your service to cause your background thread to stop running, as onDestroy() will be triggered by the call to stopService()."
"When a service is destroyed / completely stopped, Android is supposed to call onDestroy() on that service."
Edit: onCreate() Service starts; onStartCommand()someone uses service; onDestroy()Service is killed / stopped.
"In the case of a bound service, this is when there are not more active client binders."
What context does this method need to be placed within to function properly.
You most likely want to cancel discovery in your onDestroy method too.
"For instance, you want to make sure you check/cancel discovery prior to attempting to make a connection."
"Let me know if this helped... and if you are still having trouble, update your answer with your logcat output and/or any error messages you are getting, and maybe I can help you out a bit more."
"onSaveInstanceState() and onRestoreInstanceState() are only explicitly called by Android when the Activity needs to be recreated, generally after a configuration change (ex."
"After onDestroy the Service's context is invalid, so all registered intent receivers will stop operating."
You should ensure that mMediaPlayer.stop is called before the return from onDestroy.
The music does not stop because the receiver is not called any more.
Here is a semi-different way to keep the service going forever.
onDestroy() will get called when the application gets closed or killed but the runnable just starts it right back up.
A Handler is basically a callback class that Android uses to asynchronously run code when you send it messages of some form.
Please note that a thread of this nature will stay open when the activity is closed so you must kill it before the user quits.
"Supposing you don't finish() your main activity, clearing your database inside the onDestroy() method of that activity might be the closest of what you want to accomplish."
"As has been pointed in the comments, refer to http://developer.android.com/reference/android/app/Activity.html#ActivityLifecycle."
"Its compulsory that you save any user data that you want to persist in onDestroy(), because the system will not do it for you."
"OnDestroy is called when the Activity is being destroyed either by the system, or by the user, say by hitting back, until the app exits."
"Having said that, I must say you that you cannot call any of the user defined method's in onPause() and onDestroy() as they are called under certain circumstances and are not meant to do any operation other than what I specified above."
"When the Activity starts, onCreate() is called which sets up your screen followed by onResume(), you can however use onResume to do what you want, but it is highly recommended that you create another class to carry on such operations, which may sometimes be data intense."
Activity context is attached to the Activity's life-cycle and can be destroyed if the activity's onDestroy() is raised.
You cannot prevent the application from closing as the kernel may force it to shut down if the device becomes low on resources.
Allowing the application to execute its onDestroy method and then close.
"Normally, when the system is low on resources, the kernel will inform the application that it wishes to close it."
"However, it's worth remembering that you're not guaranteed that onDestroy() will execute."
The kernel may or may not give it time to do so.
You can even use different images for portrait and landscape by putting them in drawable-port and drawable-land.
"Ok, i think the question is about how to free the memory that is being allocated using malloc() inside native code."
"Inside onStop() or onDestroy(), I did a native call, which I have used to free() the allocated memory."
Setting adView.setVisibility(View.GONE) and removing the AdMob view from the view hierarchy will hide the ad and prevent user interaction in most cases.
The AdView should no longer be used after this method is called.
Have all your activities extend from a MyActivity class which has a BroadcastReceiver member: mChangeReceiver.
"Have MyActivity register mChangeReceiver in onCreate (and unregister in onDestroy), to the LOGIN_ACCOUNTS_CHANGED intent."
Have the mChangeReceiver call some abstract method onAccountChanged() that all extending classes need to override and implement to reflect the change in the GUI.
  I'd like to enforce (or at least verify) that my service is a singleton within a process.
"remember to deleteObserver() during onDestroy() is important, this way the loader don't hold a reference to your activity forever."
(the loader will probably be held alive during your Application lifecycle...)
"onDestroy() does not end your activity, it is called by the system when the activity is being destroyed."
You override it so that you can clean up your activity (e.g.
don't myThread.join() on the UI thread since it will block until the Thread finished and your App might ANR.
"You can put MyThread.interrupt() in onDestroy, onPause or onStop (+ recreate the Thread in the corresponding start callback)"
"Oh, and don't forget to remove the listener again in the Activity's onDestroy() method!"
"That's up to you - you may already know how, you may be able to put it in your Application implementation, it could be a singleton (bad), the listeners could be static (bad) or various other options."
"Regarding to you original question, it is OK to close database on onDestroy() event."
Using a Service is exactly what I have done for very similar purposes (doing socket communication for Bluetooth and TCP/IP applications) and think you'll certainly want to be using a Service if the communication should continue even when the user has closed the application.
"With a Service you have a well-defined lifecycle with appropriate lifecycle callbacks (onCreate(), onDestroy(), etc.)"
"For this reason, in my application (which uses a very large amount of global state) I've resorted to holding my singletons' actual instances in an extension of the .Application class, to (hopefully) better control their lifecycle."
"The requirement is the Activity ""A"" should not be finished."
Your activity will be called with onDestroy() if it is finished.
You can reset static variables to null or any value you want but using static variables for other things then constants is usually a bad idea - it's usually bad class design and can lead to unexpected behaviour like the one you observed.
"The value of static variables will persist as long as the class is loaded - it has almost nothing to do with Activity lifecycle (onCreate, ..., onDestroy)"
The first time you access a class from code it will get loaded and then it won't go away until there is a reason to unload it.
In onDestroy() you can set null values to those static variables..
"method (in the application) or an onDestroy() method (in an activity),"
"but there isn't much point in doing so, and there's no guarantee that"
"onDestroy() should only be called if you are somehow finishing the activity yourself, or perhaps if you are launching an activity in a separate app and Android needs to terminate your own app's process to free up RAM."
Those will be called any time your activity no longer has foreground input (onPause()) and no longer is visible (onStop()).
"As far i know, onDestroy() will be called only when the service is explicitly stopped(Force Stop)."
"When your Activity is no longer visible on the screen, it is stopped."
"However, you'll want to make sure you unbind from the Service when your Activity calls onDestroy() to make sure you don't have any dangling handlers and suchlike."
Stopping an Activity bound to a Service does not stop the Service.
You can rebind to a running Service the same way as you did the first time.
"Methods you override that are part of component creation (onCreate(), onStart(), onResume(), etc."
"Methods you override that are part of component destruction (onPause(), onStop(), onDestroy(), etc."
"), you should chain to the superclass as the first statement, to ensure that Android has its chance to do its work before you attempt to do something that relies upon that work having been done."
"), you should do your work first and chain to the superclass as the last thing."
You can verify whether this is your issue by logging calls to onCreate &amp; onDestroy.
"In the case of a destroyed activity, when the activity result needs to be processed, Android will recreate the Activity, passing a savedInstanceState to onCreate."
"you can use isFinishing() method , to check if the activity is going to be killed or onDestroy() method just called due to change in orientation"
It is called only once in the lifecycle of an activity.
onDestroy() is called when an activity finishes its life cycle.
It is also called once in the lifecycle of an activity.
"Whenever there is an orientation change, Android destroys your activity ( calls onDestroy()) and then restarts it (calls onCreate())."
"As soon as your popup is up, set a flag popup_open=1."
I'm sorry that the answer of this question wasn't actually possible to have with the elements I gave in my question.
"You also need to call it from onPause, because onDestroy is not guaranteed to be called."
"You may need to cause a garbage collection after this, in order to help the GC understand that some references to objects that were made orphans and that can be GC'd."
"  worker thread, and stops itself when it runs out of work"
One case I had to consider was when the user re-opens my app even before the long-running has completed.
"In my app, this means a new instance of JmDNS gets created."
Your use case might differ - you might want launch the cleanup thread only if it is not already running (using Thread's isAlive() method or some such technique).
Do not follow the state management test example : {dead link}
"Note that finish() caused onDestroy(), but the subsequent getActivity() was a no-op."
"Not only does getActivity() not instantiate a new Activity, it doesn't even recreate the original one."
"You shouldn't try to circumvent Android's activity workflow and memory management by avoiding onDestroy() (in fact, I think you can't)."
"Use onSaveInstanceState(Bundle) to store your current state and restore it on onCreate(Bundle), if a Bundle is provided."
Every Activity has to call acquireBinding() in their onCreate() methods and call releaseBinding() in onDestroy().
If the reference counter reaches zero the binding is released.
Perhaps you could just try calling stopForegroud(boolean) from your onDestroy() method first...
"Despite this, I cannot find anywhere recommending to save state in onDestroy() and everyone seems to recommend using onPause."
"First, you need to clarify how many types of services in Android."
Foreground: only stop when you intentionally stop it by calling stopService() in activity or fragment where you start that service or call stopSelf() in its own service.
Background: stopService() and stopSelf() do in the same way as foreground.
"Moreover, you should know this service is in the same thread with activity or fragment calling it, so if you destroy activity or fragment, this service will stop also, but without calling onDestroy()."
Don't count on onDestroy() to know when service stops because it
"Your whole process may be terminated due to low memory, but onRetainNonConfigurationInstance() is only designed for in-process use."
"Your process could be terminated due to low memory conditions (onStop() is very likely to still be called, but onDestroy() might not be if Android is in a hurry, such as due to an incoming phone call)."
"To properly handle a restart, it is important that your activity"
Create a static clean-up method in your View that you call from your Activity's onPause().
"If the bitmap is small enough, you can consider onCreate()/onDestroy() as well."
Be sure to check the bitmap reference in your view class for null before using it.
"user853583 suggestion is a good one, but if you need access to a context inside a fragment you should use getActivity().getApplicationContext()"
You should avoid passing an activity as a context whenever possible as this can introduce memory leaks - some object will hold on to that activity after its onDestroy() has been called and it won't be garbage collected.
"Having said that, there are cases when you do need to pass an activity as a context - eg: for list adapters"
"is destroyed on orientation change, be sure to unregister your receiver in your fragment, for eg inside onPause() or onDestroy()"
"onPause() will always be called before your activity is placed in the background and/or destroyed, so you do not have to save state in onStop() and onDestroy() as well."
"For the state to be preserved in SharedPreferences, you need to add editor.commit() after writing the value."
  [..] There are situations where the system will simply kill the activity's
"You are right, it is due to the orientation change."
onDestroy() and onCreate() will not be called upon return from camera.
"EDIT: If you return a cursor that is already closed, you can't use it."
"I'm sorry for not being able to provide you with some official source of information, but I was curious too to see what would happen and decided to test it."
API 17 introduced View.generateViewId() which allows you to generate a unique ID.
Apparently leaking the Activity (hanging onto it after is is destroyed) is wasteful.. :)
"One approach you could use, is check to see if the Activity isFinishing() before unbinding in your onPause()."
"If it is finishing, you would defer the unbinding to your onDestroy() method."
"Before onDestroy() is called, however, you could persist your ServiceConnection in the onRetainNonConfigurationInstance() method."
"That being said, depending on your application, you might find it is just easier to start/stop your service."
"After you call it, the Android Framework will call onDestroy() method automatically."
"Actually, these onXXX() methods(the prefix ""on"" implies that these methods are callbacks for the system) should be called by the system, not the developers."
"onStart and onStop are existing methods on an Activity, just like onCreate."
onCreate and onDestroy are not an appropriate pair of methods to use for Flurry session tracking because onDestroy is not guaranteed to be called.
You can end up with situations where the app gets killed by the system and Flurry will think the session is still going.
"Prior to Honeycomb, onRetainNonConfigurationInstance() as mentioned in the accepted answer is the best way to do this."
"Starting with Honeycomb, that's deprecated, but there is a much simpler way: call isChangingConfigurations() instead, during any of your onPause()/onStop()/onDestroy()."
You can't override when the onCreate() and onDestroy() methods get called (at least not without experiencing extraordinary amounts of pain).
The best thing for you to do is to figure out how to work within the confines of when they get called.
"Make it so that your app can tolerate this call sequence because quite frankly, it supposed/has to."
"The VideoView class implementation varies from one device to another (and the class itself is very sparsely documented), but the Gallery3D code from AOSP does call the above methods in its MovieView activity lifecycle methods, so hopefully most devices should at least make itself looks good in that scenario."
You should register and unregister your receivers onStart() and onStop().
"Like Konstantin says, onDestroy() is not guaranteed to be called, and you could continue receiving broadcasts for a long time, when the Activity is no longer open."
"The Android documentation doesn't prescribe a single place to register/unregister broadcast receivers, but it mentions both onStart()/onStop() and onResume()/onPause() as possibilities."
(Note there are other ways to implement this kind of functionality.)
It's true that onDestroy() is not guaranteed to be called if the system kills your process in order to save memory.
"However if the process is killed, the process won't be receiving broadcasts anyway."
As onDestroy() is not guaranted to be called  you shall use onPause() to deregister.
You need to launch separate service (different intent filter in the Manifest for the same serivce) in onStartCommand() you'll check the action of the intent i.e if the action has the same value as the one you specified for intent action in the manifest file and if the action matches the intent filter action name then just stop the service.
Here you just launch intent that will signal the service to stop working.
"First thing you need to ensure that your application should not get crashed at any cost and answer to your question, you should override onDestroy() method of the service and cancel notification there as it will work for you in both the cases when service stops or it crashes."
"As you can not use onDestroy() in case of crash, so you need to put try catch block and after getting exception perform your appropriate action."
"In my app, I'm using Activity.onDestroy() to do the cleanup that I need."
Step #3: Set isRunning to false in onDestroy() of the service.
Step #2: Set isRunning to true in onCreate() of the service.
Step #4: Examine isRunning to see if the service is running.
"When you start Activity from Activty, onPause() and onStop() method called instead of onDestroy()."
onDestroy() calls when you hit back button or call finish() method.
"Hence, broadcast receiver should be registered in onStart() or onResume(), and unregister receiver in onPause() or onStop()."
You can then register your Broadcast receiver with the same method in the onCreate() and unregister in the onDestroy().
You cannot catch those intents through XML (I forget why).
"However, you could use a Service that registers a BroadcastReceiver member in its onStartCommand() and unregisters it in its onDestroy()."
"Well, you can, but you must track Activity lifecycle and release the reference after its onDestroy() is called."
Storing references to Activity is the first thing you shouldn't do with activities.
flag fromOrientation(tells the state either configuration had been change or not)
If orientation changed(onRetainNonConfigurationInstance()) then we set the flag value in preference which let us know whether onCreate() is called from on orientation or not.
In this case onDestroy() is not called as the Android OS will reclaim resources anyway (this is a basic task of the OS in general).
  A service can be both started and have connections bound to it.
"  hold, the service's onDestroy() method is called and the service is"
In this case onDestroy() is called as this is the place where the app can release its resources.
The OS gives the app a chance to release the Service's resources to prevent memory leaks.
Of course in this case the application's process stays untouched (as there may be other Services/Activities running in it).
I'm not sure where you're seeing that a Service is guaranteed to have onDestroy() called.
"As to whether a service-only process can be abruptly killed by the OS: yes, it can."
"They may be called or not each time you are switching from a tab to another, and your application needs being able to handle this."
"A rift is formed in the space-time continuum, threatening extinction of all life in the universe, until the day is saved by a bunch of humans in brightly-colored funny-looking outfits (including some with capes, if you can believe it)."
"In fact, if you implement a content provider, you will have this same effect, as content providers are not called with any sort of onDestroy() method, meaning you will never have an opportunity to close your database."
A content provider will just live until the process is terminated.
I've never faced any problems calling the super methods before my code and I'm pretty sure I wouldn't have faced any problems if I had called the super methods after my code.
"The AsyncTask has a thread pool, so even if your work is finished threads are not terminated, that is probably what you are seeing in the debugger."
What you might want to do is make sure your AsyncTask doesn't hold a reference to the activity and vice versa.
"Keep in mind that regardless of GC, if Android is low on memory, it will just terminate the process of your unused activity, so memory will be eventually reclaimed."
"1) Implement your doInBackground() in such a way, so it checks whether AsyncTask is cancelled."
The behavior you describe with ActivityA.onResume() being called is not correct.
The timing of onStop() and onDestroy() are a little less defined.
"Here's an example that works, but onStop() and onDestroy() aren't called until the user hits the back button (but onResume() is never called)."
If I call finish() after launching ActivityB then they're called on ActivityA earlier.
It's just a workaround and the real solution should actually be incorporated in the ListView.
"UPDATE (2/12/2012): After further investigation, this problem is actually not particularly related to ListView nor to OnItemClickListener, but to the fact that GC doesn't happen immediately and need time to decide which objects are eligible and ready for GC."
"The solution is to break any references to the listener (the junkowner), in this case from the button, which practically makes the listener as a GCroot with only short path to the junk and make the GC decide faster to reclaim the junk memory."
There you can play your sound and then call the super method to finish.
The code you show is for binding to a service.
"In that case, if we ignore configuration changes, the proper way to unwind matters would be to, in onDestroy(), call some removeListener() method on the Binder, then call unbindService()."
"In onServiceConnected(), you are calling some sort of setListener() method on the Binder"
"Configuration changes, particularly in a pre-fragment world, make this complicated."
"In onDestroy(), if the flag from Step #3 above is false (i.e., we are not undergoing a configuration change), call some removeListener() method on the Binder, then call unbindService()."
"In onCreate(), use getLastNonConfigurationInstance() -- if it is null, proceed as normal, but if it is not null, hold onto that Binder and Listener and don't re-bind and re-register the listener"
"Using fragments with setRetainInstance(true) can probably simplify this some, though I have not worked through a sample for that yet."
"In Android, there's an important distinction between a running service and a running process."
A service follows a carefully defined lifecycle; it begins when onStartCommand() is called and ends after onDestroy() is finished.
"During that lifetime, the service can be performing tasks or sitting idle, but it is still running."
"Bottom line: if onDestroy has been called, your service has stopped."
"It's definitely confusing at first, but once your service has stopped, you don't need to care about the process it was in."
The service can be cut at any time through the settings menu.
onDestroy() will be called regardless so use that to store anything needed.
It can also be killed at any time by Android if it decides it needs the resources for the currently running activity.
The service runs in the background but through the main UI thread.
"When you get a sensor reading, or after a timeout (hint: phones don't always change orientation), or in onDestroy() (if Android decides to shut down your service), unregister the listener and call stopSelf() to shut down the service."
"Please have your BroadcastReceiver delegate work to a Service (via startService()), where in onStartCommand() you register the SensorListener."
"It's better to save your data in onPause() because this is last method that's guaranteed to be called, after that there is no guarantees for any of the Activity's lifecycle methods to be called."
"If data in Activity member should not be persisted across process starts, you can save it in your onDestroy() too."
"If process is not killed, onDestroy() is also guaranteed to be called."
Those trigger destruction of old Activity and creation of new Activity instance.
"In Android 3.x (API Level 11), you can call isChangingConfigurations() to see if the activity is being destroyed due to a configuration change."
"Prior to that, override onRetainNonConfigurationInstance() and set a boolean data member (e.g., isChangingConfigurations) to true, and check that data member in onDestroy()."
onDestroy is probably the best phase to place disposal method of any IO connection.
There are situations when you have to verify in onDetach or in onDestroy if the progress dialog is still visible.
"onDestroy() is not guaranteed to be called, on any component."
  I need to trap that event so that I can close files.
"An Application context lasts, as long as your app is alive, while the Activity context dies with your Activity (it is not valid after onDestroy of that Activity)."
"I'm not sure if this is frowned upon or not, but this is how I do it..."
"Step 2 - in each of your activities, override the onStart() and onDestroy() methods."
"In onStart(), set the static variable in your App class equal to ""this""."
"Perhaps your Service's onDestroy() method should call a stopProcessing() method on your Runnable, which will set the 'running' boolean to false."
You want to make it something that you can update.
"are called from such a thread), then you can use Handler."
"As mentioned in other answers, the exception is being thrown because each call to registerReceiver is not being matched by exactly one call to unregisterReceiver."
An Activity does not always have a matching onDestroy call for every onCreate call.
"If the system runs out of memory, your app is evicted without calling onDestroy."
"The correct place to put a registerReceiver call is in the onResume call, and unregisterReceiver in onPause."
Start the location listener on the activity you wants to start the gps.
Its better you write the GPS start on the onCreate()/onStart() and the GPS remove on the onDestroy() of a service and use that service.
Otherwise once you stop the GPS the chance of starting the GPS again is less than 50% in some devices.
You can use the addOnAccountsUpdatedListener method of AccountManager to add a listener in the onCreate method of an Activity or Service -- make sure you remove the listener in your onDestroy method (i.e.
do NOT use this in an endlessly running service) or the Context used to retrieve the AccountManager will never be garbage collected
"From my experience, if your application is designed to work in both portrait and landscape orientation, you need to declare the variable cam as static."
"Otherwise, onDestroy(), which is called on switching orientation, destroys it but doesn't release Camera so it's not possible to reopen it again."
Implement another procedure that's called in your override of onResume().
"The latter is not intended to be called by you, it's a convenience method that tidies up or readies the activity when its state changes to resume."
Based on the above the only way to prevent is to make sure there are no references to the offending activity after onDestroy.
"The problem is that some there may be some WeakReferences which are still accessible through some native objects, which seem to have a different lifecycle."
"The MediaPlayer instance would be created in play(uri) if it isn't already instantiated, and released in your service's onDestroy()."
"With AIDL and binding, you could expose custom functions such as play(uri), pause(), rewind(), etc...."
You can even register a listener with a RemoteCallbackList to get notified about position changes or some other events.
Always make sure to call removeCallbacks again in the onDestroy method to prevent this kind of problems.
"The broadcast is more loosely coupled and so might be easier to code up though: you just broadcast the Intent in the Activity and don't require any more thought, and in the Service you don't have to do any work dealing with binders, just register a receiver in your onCreate() and unregister it in onDestroy()."
You don't actually have to track anything about the Service.
You've placed unregisterOnSharedPreferenceChangeListener() in onDestroy() and it's not called on all activity restarts.
Here is a complete example including how to stop the service.
"1) Yes, I think your understanding is correct (I say I think because I think I understand what you're saying ;-) )."
"In general, onDestroy() means your activity is about to be killed."
That should allow you to start the service and keep it running regardless of what happens to the calling Context
"When you rotate the display, the Activity is killed and recreated."
eventually dismiss() it on onDestroy() to avoid the window leak error.
Note that leaving the activity when a dialog not dismissed causes the memory leak.
You shouldn't have a  in every method getSomethingCursor as requesting a database object is expensive ( I think I read it in SO).
You should be overriding onCreate(Bundle) instead of filling out the default class constructor.
"Yes, you should close the adapter and cursors once you don't need them anymore (for instance, when you finish your activity)."
"onDestroy doesn't mean that the activity object was deleted, it just means that the activity itself (as an Android concept) was destroyed."
"Even IF it was garbage collected (which could happen much later after onDestroy, at a point way down the road when the system actually had to do a garbage collection because it needed memory), there's no guarantee finalize gets called."
"Internally, the OS may decide to recycle it, especially when it's immediately recreated due to a configuration change (like the orientation changing from portrait to landscape)."
"Dismissing the PD onDestroy doesn't work for some reason and when I've tried it, each Back button press would close the app although canGoBack() was set to true."
"The PD problem occurs only when the app exiting on back button (Usually when the user presses it repetitively, and only sometimes (not all the times) the PD is called when the app already destroyed."
Your Activity doesn't get killed by the OS while it's in the foreground.
"As the doc says, save all persistent data in onPause()."
"(I wouldn't be surprised if Dianne steps in and corrects me here, btw.)"
You should call sqliteHelper.open() in onCreate() and sqliteHelper.close() in onDestroy().
"All callbacks you override (onCreate(), onDestroy()...) are at least indirecty dispatched from that loop."
You can see that for example in the stack trace of an exception.
"Binnyb is right, most likely your database is closed in background activity onDestroy while the error raises in the active activity."
You have to open/close database just at the time you need to save/retrieve the data.
"  Starting a service, copying the data to the service somehow (would this be slow?)"
"(If you kill your process in the middle of event handling, all kinds of bad things&mdash;like the touch focus going into the ether&mdash;can happen.)"
You can do that even without checking if runnable was already fired while your activity was active.
"When this happens, the following methods are invoked: onStop (calling isFinishing returns false), onRetainNonConfigurationInstance and onDestroy."
A few seconds later (usually ~15s) the device enters into sleep mode (is this the correct name?)
"Now, the strange behaviour begins: just after the last onDestroy finishes, another activity is created: onCreate, onStart, onRestoreInstanceState, onResume and finally onPause are invoked."
"The onDestroy is there to let your app have a final chance to clean things up before the activity does get destroyed but it does not mean that the activity will, in fact, be GCed."
Here is a good article that I recommend people to read that relates to creating an exit button.
"You mentioned that closing it in onDestroy() ""leaves vulnerabilities"" in any non-UI threads that are still running."
"(In larger applications, you'll also start to see Memory Leak Detection warnings.)"
"(All I can tell right now is that you don't show an onDestroy method, but this is clearly just a portion of your code.)"
"A well-written activity should not care if onDestroy() is called, as it is guaranteed to NOT always be called."
"For example, Android can terminate your process whenever it wants (e.g., extreme low memory conditions)."
The fact that you need onDestroy() to work reliably suggests there are problems that should be resolved.
One of the most common errors that I found developing Android Apps is the
"You must do this before your activity goes out of scope, such as in onPause() or onDestroy()."
"  To unregister a listener, pass the listener object and set the events argument to LISTEN_NONE (0)."
"However, the active/running state is the green ""activity is running"" bubble, the paused state is the white ""The activity is no longer visible"" bubble, and the stopped state would be in between onStop() and onDestroy()."
"The non-existence ""state"" would be the red ""Process is killed"" bubble."
A particularly feisty example is when you decide to show a managed Dialog from an Activity using showDialog().
"If the user rotates the screen while the dialog is still open (we call this a ""configuration change""), then the main Activity will go through all the ending lifecycle calls up untill onDestroy(), will be recreated, and go back up through the lifecycles."
"What you might not expect however, is that onCreateDialog() and onPrepareDialog() (the methods that are called when you do showDialog() and now again automatically to recreate the dialog - automatically since it is a managed dialog) are called between onStart() and onResume()."
"i would keep it open the whole time, and close it in some lifecycle method such as onStop or onDestroy."
"that way, you can easily check if the database is already in use by calling isDbLockedByCurrentThread or isDbLockedByOtherThreads on the single SQLiteDatabase object every time before you use it."
"If not, I believe that might be the solution - and you stop your Timer or whatever you're using to run the service within onDestroy()."
"  A service can be stopped by calling its stopSelf() method, or by calling Context.stopService()."
It seems to me that onDestroy is called when GC reclaims the service.
onDestroy is an instance method and any memory it releases (or allows the garbage collector to release) will be of the corresponding instance.
Activities are not singleton; there can be more than one instance of an Activity.
"You can do it either way, it depends if you want your superclass's onDestroy() called before yours."
"*Most likely, android is free to kill the activity at any time, but you can assume it's still there."
It really depends on what you want to do in your onDestroy.
"If the logic you put inside onDestroy has something to do with those three things that android does, then you may have to worry about the order."
"Otherwise, and in most of the cases, it does not matter."
"We just set the text of the toast using toast.setText(""string""), and call toast.cancel() method in onDestroy() method."
"A service, as mentioned above, can be used for longer-running operations that will continue even if you have no foreground activity, but they can, and eventually will be killed by Android's lifecycle if left in the ""background"" state."
"For example, I have an app that uses a foreground Service to record accelerometer data all night while the android device is next to the user's body."
The timing of onDestroy() after the last unbindService() is indeterminate and certainly asynchronous.
"You could also try calling stopService() yourself, but that too is asynchronous, so you don't know when it will be stopped."
"Now, the stack trace suggests that line 74 is in onDestroy()."
"You will see that Activity.onDestroy() only gets called in the case of a controlled shutdown of the activity - something that happens extremely rarely, as the Android OS can kill your process in a variety of states without ever calling your onDestroy() method."
"While it is running onDestroy(), your app has (probably) as much time as it would like to - the fact that it is even running onDestroy() means that the OS did not select it to be killed."
"As pointed out by jhominal, the onDestroy() method is probably not where you want to do your clean-up/save preferences/etc."
The ANR dialog will normally pop up if your application is un-responsive for 5 seconds.
"Regardless of where you choose to do this, be it onDestroy(), onSaveInstanceState() or in onPause(), I believe the general 5 second rule will apply."
"If what you're doing takes more than 5 seconds, the ANR dialog will show and the user can choose to force-close your app."
You could open the database in onCreate() and close it in onDestroy().
"To get the entire time the app is up, you would want to diff between onCreate() and onDestroy() of your foremost Activity class."
"For just the time the app is in the foreground, use onResume() and onPause() in each of your Activity classes and sum the time from each class."
Per the first half of your question: you should get what you want if you call stopMediaPlayer() inside onPause() and onDestroy().
The UIThread is the main thread of execution for your application.
"Additionally, this is where all of the updates to the UI are made."
"  I was expecting the onDestroy method to be called, but it doesnt!"
You do not receive any notification when your task is killed in this fashion.
There are various scenarios in which onDestroy() of an activity or service will not be called.
"You can register and unregister broadcast receivers with an activity, but a simple call like isRegistered(BroadcastReceiver) in the Activity class might be very useful."
"A service is not automatically ""in the background"" from a threading standpoint, in that onCreate(), onDestroy(), onStart(), and onBind() are all called on the main application thread, the same thread shared by all the activities of this application."
"A service is ""in the background"" from a UI standpoint, in that it has no UI."
"Anything long-running, like a download, needs to be done outside of the main application thread, such as using an AsyncTask."
your issue can be solved if you use a custom Application class.
Now only you require to get the application object in your Activity like this
My best guess is that onDestroy() is not being called on your service.
Calling cancelAll() on the NotificationManager should get rid of all outstanding notifications from your application.
"That would occur if something else is keeping the service in memory (e.g., you have an active bound connection to it via bindService())."
"Basically, from which class you started progressDialog, override onDestroy() method and do this way."
Manually re-associate the new activity to the AsyncTask in onCreate().
"You should close your database at some point (e.g., onDestroy() of the service that is mediating your database)."
  My problem is that when testing on a
"Close it when all activities have unbound from the service that is mediating the database connection, triggering that service's onDestroy() method."
"Or, open a fresh connection in each component that needs access to the database, and use Java synchronization to ensure two threads do not try to simultaneously use the database (if needed)."
Here is a complete example including how to start/stop the service.
You should not be getting that message if you close the Cursor in onStop() or onDestroy().
"Either use a Service, or pass your ImageLoader to the next instance of your activity via onRetainNonConfigurationInstance() (e.g., isFinishing() is false in onDestroy(), so this is a rotation)."
"Calling AsyncTask.cancel() DOES trigger onCancelled() in the AsyncTask, but for some reason by the time that method is called, the View has already been destroyed and thus cancelling the dialog is failing."
"Don't forget to call mSoundPoolHelper.release();, for instance in your onDestroy()."
"Well-behaved activities will not register content observers without unregistering them at an appropriate time (e.g., onDestroy())."
"Only if you like leaking memory, and then only until Android terminates the process."
Initially I prepared some data and set it as activity result in onDestroy (this did not work).
"Now I set activity data each time the data to be returned is updated, and have nothing in onDestroy."
"I'm short on time so can't give a full detailed answer, but in brief, here are my suggestions."
"That's guaranteed to get called; according to the official documentation on Lifecycles, only onPause() is guaranteed."
"On the other hand, Service can't be killed by system silently, at least onDestroy() method should be called first."
"Having such callback, you can save your state to some persistent memory (like SharedPreferences, file, database, etc) and restore that state next time your Application or Service starts."
Cursor and close it whenever needed (in onDestroy() for instance.)
that with managedQuery() the activity will keep a reference to your
"onDestroy(), you will leak underlying resources (logcat will warn you"
"Every life cycle event like onCreate, onResume, onPause.... onDestroy of an Activity is always called on a single thread - The ""Main thread""."
In short this thread is backed by a Queue into which all the activity events are getting posted.
To start the service at boot time you need an auto starter.
"It calls onDestroy on my Activity, and then while the screen is off creates my Activity again, calling onCreate!"
"Note that the semantics here is that the entire time your Activity is running it needs the Service, so if this Service is running in another process then you have increased the weight of it and made it more likely for it to be killed while in the background."
"Doing it here can have other unexpected negative consequences: for example if multiple Activitys in your app bind to the same Service, when there is a transition between two of those activities the Service may also get destroyed and recreated as the current Activity is paused before the next one is resumed."
"To make the Timer go away when your service is stopped, you need to call cancel() on the Timer in the appropriate callback method for the service; onDestroy by the looks of it."
"There isn't a way of finding out &mdash; you should only be calling registerReceiver once, most likely upon the creation of your service."
"You need to keep a reference to the BroadcastReceiver too for when you call unregisterService (onDestroy() is the natural place for it), otherwise the system will warn you about leaking broadcast receivers and get angry and possibly shout at you."
"The error message is fairly self-explanatory: you are leaking a ServiceConnection, by which Android means you are calling bindService() but are not calling unbindService(), and the activity that called bindService() was destroyed."
"Make sure you call unbindService() in onDestroy(), if not sooner."
you can kill it conditionally at the end of onDestroy() with java.lang.System.exit(0) (or perhaps restartPackage(..)?).
"Of course do it only in the case where you want to ""really end the app"", because the onDestroy() is part of the normal lifecycle of activities and not an app end at all."
You can't use Application.onTerminate() since there's no guarantee that this will be called.
For the same reason reason you can't use onStop() or onDestroy() from Activity either.
"You haven't provided any of your code from LightFactoryRemote, so this is only a presumption, but it looks like the kind of problem you'd be seeing if you were using the bindService method on it's own."
"To ensure a service is kept running, even after the activity that started it has had its onDestroy method called, you should first use startService."
You should only need to unbind the service in onDestroy().
"  groupings you will use: onCreate() and onDestroy(), onStart() and"
"  As the Activity doc tries to explain, there are three main bind/unbind"
"You should do the unbinding in onPause instead, so that there are always matching pairs of bind/unbind calls."
Not entirely sure how you could handle this... Perhaps when onServiceConnected is called you could call unbindService if onDestroy has already been called.
One of the most common errors that I found developing Android Apps is the “java.lang.OutOfMemoryError: Bitmap Size Exceeds VM Budget” error.
"""If you start an android Service with startService(..) that Service will remain running until you explicitly invoke stopService(..)."
"Once neither of these situations hold, the Service's onDestroy() method is called and the service is effectively terminated."
"In such a case, the system will keep the service running as long as either it is started or there are one or more connections to it with the Context.BIND_AUTO_CREATE flag."
"All cleanup (stopping threads, unregistering receivers) should be complete upon returning from onDestroy()."""
"By saying ""doesn't work"", I guess you mean that the onDestroy()-method of the service is not invoked."
"That's probably why onCreate() gets invoked every time instead of onNewIntent(), which would only be called if the activity is already existing."
"If the above (BACK-button) wasn't your problem, implementing these dummies will at least help you debugging it a bit better."
Override your service's onDestroy() method and watch what event flow leads to it.
I'd suggest using an AsyncTask instead of your own thread in this scenario.
"Use a singleton (i.e., make your BackgroundService object available from a static context, such as a public static data member, nulling out that static reference in onDestroy())."
Follow the LocalServiceBinding API sample to return an IBinder that simply gives access to the BackgroundService object.
There isn't even anything in the source code in this area that suggests there is some sort of onDestroy() that just isn't surfaced in the SDK.
"Call stop() within the audio playing activity (in onDestroy()), for example"
"Create a Service to play audio, and communicate with it from both activities"
onDestroy isn't always called in the service so this is useless!
For example: Just run the app again with one change from Eclipse.
The following steps can be used to check stop service with/without calling onDestroy().
onDestroy() called: Go to Settings -> Application -> Running Services -> Select and stop your service.
"onDestroy() not Called: Go to Settings -> Application -> Manage Applications -> Select and ""Force Stop"" your application in which your service is running."
"However, as your application is stopped here, so definitely the service instances will also be stopped."
